{"/home/travis/build/npmtest/node-npmtest-esperanto/test.js":"/* istanbul instrument in package npmtest_esperanto */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-esperanto/lib.npmtest_esperanto.js":"/* istanbul instrument in package npmtest_esperanto */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_esperanto = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_esperanto = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-esperanto/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-esperanto && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_esperanto */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_esperanto\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_esperanto.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_esperanto.rollup.js'] =\n            local.assetsDict['/assets.npmtest_esperanto.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_esperanto.__dirname + '/lib.npmtest_esperanto.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/dist/esperanto.js":"/*\n\tesperanto.js v0.7.6 - 2016-07-21\n\thttp://esperantojs.org\n\n\tReleased under the MIT License.\n*/\n\n'use strict';\n\nvar chalk = require('chalk');\nchalk = ('default' in chalk ? chalk['default'] : chalk);\nvar acorn = require('acorn');\nvar MagicString = require('magic-string');\nMagicString = ('default' in MagicString ? MagicString['default'] : MagicString);\nvar _path = require('path');\nvar sander = require('sander');\n\nfunction hasNamedImports(mod) {\n\tvar i = mod.imports.length;\n\n\twhile (i--) {\n\t\tif (mod.imports[i].isNamed) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nfunction hasNamedExports(mod) {\n\tvar i = mod.exports.length;\n\n\twhile (i--) {\n\t\tif (!mod.exports[i].isDefault) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nvar shouldSkip = undefined;\nvar shouldAbort = undefined;\nfunction walk(ast, _ref) {\n\tvar enter = _ref.enter;\n\tvar leave = _ref.leave;\n\n\tshouldAbort = false;\n\tvisit(ast, null, enter, leave);\n}\n\nvar context = {\n\tskip: function () {\n\t\treturn shouldSkip = true;\n\t},\n\tabort: function () {\n\t\treturn shouldAbort = true;\n\t}\n};\n\nvar childKeys = {};\n\nvar toString = Object.prototype.toString;\n\nfunction isArray(thing) {\n\treturn toString.call(thing) === '[object Array]';\n}\n\nfunction visit(node, parent, enter, leave) {\n\tif (!node || shouldAbort) return;\n\n\tif (enter) {\n\t\tshouldSkip = false;\n\t\tenter.call(context, node, parent);\n\t\tif (shouldSkip || shouldAbort) return;\n\t}\n\n\tvar keys = childKeys[node.type] || (childKeys[node.type] = Object.keys(node).filter(function (key) {\n\t\treturn typeof node[key] === 'object';\n\t}));\n\n\tvar key = undefined,\n\t    value = undefined,\n\t    i = undefined,\n\t    j = undefined;\n\n\ti = keys.length;\n\twhile (i--) {\n\t\tkey = keys[i];\n\t\tvalue = node[key];\n\n\t\tif (isArray(value)) {\n\t\t\tj = value.length;\n\t\t\twhile (j--) {\n\t\t\t\tvisit(value[j], node, enter, leave);\n\t\t\t}\n\t\t} else if (value && value.type) {\n\t\t\tvisit(value, node, enter, leave);\n\t\t}\n\t}\n\n\tif (leave && !shouldAbort) {\n\t\tleave(node, parent);\n\t}\n}\n\nfunction getId(m) {\n\treturn m.id;\n}\n\nfunction getName(m) {\n\treturn m.name;\n}\n\nfunction quote(str) {\n\treturn \"'\" + JSON.stringify(str).slice(1, -1).replace(/'/g, \"\\\\'\") + \"'\";\n}\n\nfunction req(path) {\n\treturn \"require(\" + quote(path) + \")\";\n}\n\nfunction globalify(name) {\n\tif (/^__dep\\d+__$/.test(name)) {\n\t\treturn 'undefined';\n\t} else {\n\t\treturn \"global.\" + name;\n\t}\n}\n\n/*\n\tThis module traverse a module's AST, attaching scope information\n\tto nodes as it goes, which is later used to determine which\n\tidentifiers need to be rewritten to avoid collisions\n*/\n\nfunction Scope(options) {\n\toptions = options || {};\n\n\tthis.parent = options.parent;\n\tthis.names = options.params || [];\n}\n\nScope.prototype = {\n\tadd: function (name) {\n\t\tif (! ~this.names.indexOf(name)) // redeclaration of existing binding\n\t\t\tthis.names.push(name);\n\t},\n\n\tcontains: function (name, ignoreTopLevel) {\n\t\tif (ignoreTopLevel && !this.parent) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (~this.names.indexOf(name)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.parent) {\n\t\t\treturn this.parent.contains(name, ignoreTopLevel);\n\t\t}\n\n\t\treturn false;\n\t}\n};\nfunction annotateAst(ast, options) {\n\tvar trackAssignments = options && options.trackAssignments;\n\n\tvar scope = new Scope();\n\tvar blockScope = new Scope();\n\tvar declared = {};\n\tvar topLevelFunctionNames = [];\n\tvar templateLiteralRanges = [];\n\n\tvar envDepth = 0;\n\n\twalk(ast, {\n\t\tenter: function (node) {\n\t\t\tif (node.type === 'ImportDeclaration' || node.type === 'ExportSpecifier') {\n\t\t\t\tnode._skip = true;\n\t\t\t}\n\n\t\t\tif (node._skip) {\n\t\t\t\treturn this.skip();\n\t\t\t}\n\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'FunctionExpression':\n\t\t\t\tcase 'FunctionDeclaration':\n\n\t\t\t\t\tenvDepth += 1;\n\n\t\t\t\t// fallthrough\n\n\t\t\t\tcase 'ArrowFunctionExpression':\n\t\t\t\t\tif (node.id) {\n\t\t\t\t\t\taddToScope(node);\n\n\t\t\t\t\t\t// If this is the root scope, this may need to be\n\t\t\t\t\t\t// exported early, so we make a note of it\n\t\t\t\t\t\tif (!scope.parent && node.type === 'FunctionDeclaration') {\n\t\t\t\t\t\t\ttopLevelFunctionNames.push(node.id.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar names = node.params.map(getName);\n\n\t\t\t\t\tnames.forEach(function (name) {\n\t\t\t\t\t\treturn declared[name] = true;\n\t\t\t\t\t});\n\n\t\t\t\t\tscope = node._scope = new Scope({\n\t\t\t\t\t\tparent: scope,\n\t\t\t\t\t\tparams: names // TODO rest params?\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'BlockStatement':\n\t\t\t\t\tblockScope = node._blockScope = new Scope({\n\t\t\t\t\t\tparent: blockScope\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VariableDeclaration':\n\t\t\t\t\tnode.declarations.forEach(node.kind === 'let' ? addToBlockScope : addToScope);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ClassExpression':\n\t\t\t\tcase 'ClassDeclaration':\n\t\t\t\t\taddToScope(node);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MemberExpression':\n\t\t\t\t\t!node.computed && (node.property._skip = true);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Property':\n\t\t\t\t\tnode.key._skip = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TemplateLiteral':\n\t\t\t\t\ttemplateLiteralRanges.push([node.start, node.end]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ThisExpression':\n\t\t\t\t\tif (envDepth === 0) {\n\t\t\t\t\t\tnode._topLevel = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AssignmentExpression':\n\t\t\t\t\tassignTo(node.left);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'UpdateExpression':\n\t\t\t\t\tassignTo(node.argument);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t\tleave: function (node) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'FunctionExpression':\n\t\t\t\tcase 'FunctionDeclaration':\n\n\t\t\t\t\tenvDepth -= 1;\n\n\t\t\t\t// fallthrough\n\n\t\t\t\tcase 'ArrowFunctionExpression':\n\n\t\t\t\t\tscope = scope.parent;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'BlockStatement':\n\t\t\t\t\tblockScope = blockScope.parent;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction assignTo(node) {\n\t\tif (trackAssignments && node.type === 'Identifier' && node.name === trackAssignments.name) {\n\t\t\t// This is possibly somewhat hacky. Open to alternative approaches...\n\t\t\t// It will yield false positives if `foo` in `export default foo` is shadowed\n\t\t\t(trackAssignments._assignments || (trackAssignments._assignments = [])).push({\n\t\t\t\tscope: scope,\n\t\t\t\tnode: node\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction addToScope(declarator) {\n\t\tvar name = declarator.id.name;\n\n\t\tscope.add(name);\n\t\tdeclared[name] = true;\n\t}\n\n\tfunction addToBlockScope(declarator) {\n\t\tvar name = declarator.id.name;\n\n\t\tblockScope.add(name);\n\t\tdeclared[name] = true;\n\t}\n\n\tast._scope = scope;\n\tast._blockScope = blockScope;\n\tast._topLevelNames = ast._scope.names.concat(ast._blockScope.names);\n\tast._topLevelFunctionNames = topLevelFunctionNames;\n\tast._declared = declared;\n\tast._templateLiteralRanges = templateLiteralRanges;\n}\n\n/**\n * Inspects a module and discovers/categorises import & export declarations\n * @param {object} ast - the result of parsing `source` with acorn\n * @param {string} source - the module's original source code\n * @param {array} comments - {start, end} position of comments\n * @returns {object} - { imports, exports, defaultExport }\n */\nfunction findImportsAndExports(ast, source, comments) {\n\tvar imports = [];\n\tvar exports = [];\n\tvar defaultExport = undefined;\n\tvar previousDeclaration = undefined;\n\n\tast.body.forEach(function (node) {\n\t\tvar passthrough, declaration;\n\n\t\tif (previousDeclaration) {\n\t\t\tif (previousDeclaration.node.type === 'ImportDeclaration' && node.type !== 'ImportDeclaration') {\n\t\t\t\t// For last import statement, next declaration starts at next comment or node, whichever is closest\n\t\t\t\tvar nextComment = undefined;\n\t\t\t\tfor (var i = 0, len = comments.length; i < len; i++) {\n\t\t\t\t\tif (comments[i].start > previousDeclaration.end) {\n\t\t\t\t\t\tnextComment = comments[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nextComment && nextComment.start < node.start) {\n\t\t\t\t\tpreviousDeclaration.next = nextComment.start;\n\t\t\t\t} else {\n\t\t\t\t\tpreviousDeclaration.next = node.start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpreviousDeclaration.next = node.start;\n\t\t\t}\n\n\t\t\tif (node.type !== 'EmptyStatement') {\n\t\t\t\tpreviousDeclaration = null;\n\t\t\t}\n\t\t}\n\n\t\tif (node.type === 'ImportDeclaration') {\n\t\t\tdeclaration = processImport(node);\n\t\t\timports.push(declaration);\n\t\t} else if (node.type === 'ExportDefaultDeclaration') {\n\t\t\tdeclaration = processDefaultExport(node, source);\n\t\t\texports.push(declaration);\n\n\t\t\tif (defaultExport) {\n\t\t\t\tthrow new Error('Duplicate default exports');\n\t\t\t}\n\t\t\tdefaultExport = declaration;\n\t\t} else if (node.type === 'ExportNamedDeclaration') {\n\t\t\tdeclaration = processExport(node, source);\n\t\t\texports.push(declaration);\n\n\t\t\tif (node.source) {\n\t\t\t\t// it's both an import and an export, e.g.\n\t\t\t\t// `export { foo } from './bar';\n\t\t\t\tpassthrough = processImport(node, true);\n\n\t\t\t\tpassthrough.specifiers.forEach(function (e) {\n\t\t\t\t\t// the import in `export { default } from 'foo';`\n\t\t\t\t\t// is a default import\n\t\t\t\t\tif (e.name === 'default') {\n\t\t\t\t\t\te.isDefault = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\timports.push(passthrough);\n\n\t\t\t\tdeclaration.passthrough = passthrough;\n\t\t\t}\n\t\t}\n\n\t\tif (declaration) {\n\t\t\tpreviousDeclaration = declaration;\n\t\t}\n\t});\n\n\t// catch any trailing semicolons\n\tif (previousDeclaration) {\n\t\tpreviousDeclaration.next = source.length;\n\t\tpreviousDeclaration.isFinal = true;\n\t}\n\n\treturn { imports: imports, exports: exports, defaultExport: defaultExport };\n}\n\n/**\n * Generates a representation of an import declaration\n * @param {object} node - the original AST node\n * @param {boolean} passthrough - `true` if this is an `export { foo } from 'bar'`-style declaration\n * @returns {object}\n */\nfunction processImport(node, passthrough) {\n\tvar x = {\n\t\tmodule: null, // used by bundler - filled in later\n\t\tnode: node,\n\t\tstart: node.start,\n\t\tend: node.end,\n\t\tpassthrough: !!passthrough,\n\n\t\tpath: node.source.value,\n\t\tspecifiers: node.specifiers.map(function (s) {\n\t\t\tif (s.type === 'ImportNamespaceSpecifier') {\n\t\t\t\treturn {\n\t\t\t\t\tisBatch: true,\n\t\t\t\t\tname: s.local.name, // TODO is this line necessary?\n\t\t\t\t\tas: s.local.name,\n\t\t\t\t\torigin: null // filled in later by bundler\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (s.type === 'ImportDefaultSpecifier') {\n\t\t\t\treturn {\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tname: 'default',\n\t\t\t\t\tas: s.local.name,\n\t\t\t\t\torigin: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname: (!!passthrough ? s.exported : s.imported).name,\n\t\t\t\tas: s.local.name,\n\t\t\t\torigin: null\n\t\t\t};\n\t\t})\n\t};\n\n\t// TODO have different types of imports - batch, default, named\n\tif (x.specifiers.length === 0) {\n\t\tx.isEmpty = true;\n\t} else if (x.specifiers.length === 1 && x.specifiers[0].isDefault) {\n\t\tx.isDefault = true;\n\t\tx.as = x.specifiers[0].as;\n\t} else if (x.specifiers.length === 1 && x.specifiers[0].isBatch) {\n\t\tx.isBatch = true;\n\t\tx.as = x.specifiers[0].name;\n\t} else {\n\t\tx.isNamed = true;\n\t}\n\n\treturn x;\n}\n\nfunction processDefaultExport(node, source) {\n\tvar d = node.declaration;\n\n\tvar result = {\n\t\tnode: node,\n\t\tisDefault: true,\n\t\tstart: node.start,\n\t\tend: node.end,\n\t\tvalue: source.slice(d.start, d.end),\n\t\tvalueStart: d.start,\n\t\thasDeclaration: null,\n\t\ttype: null,\n\t\tname: null\n\t};\n\n\t// possible declaration types:\n\t//   * FunctionExpression  - `export default function () {...}`\n\t//   * FunctionDeclaration - `export default function foo () {...}`\n\t//   * ClassExpression     - `export default class {...}`\n\t//   * ClassDeclaration    - `export default class Foo {...}`\n\tvar match = /^(Function|Class)(Declaration)?/.exec(d.type);\n\n\tif (match) {\n\t\tresult.hasDeclaration = true;\n\t\tresult.type = (match[2] ? 'named' : 'anon') + match[1];\n\n\t\tif (match[2]) {\n\t\t\tresult.name = d.id.name;\n\t\t}\n\t}\n\n\t// if no match, we have an expression like `export default whatever`\n\telse {\n\t\t\tresult.type = 'expression';\n\t\t\tresult.name = 'default';\n\t\t}\n\n\treturn result;\n}\n\n/**\n * Generates a representation of an export declaration\n * @param {object} node - the original AST node\n * @param {string} source - the original source code\n * @returns {object}\n */\nfunction processExport(node, source) {\n\tvar result = {\n\t\tnode: node,\n\t\tstart: node.start,\n\t\tend: node.end,\n\t\tvalue: null,\n\t\tvalueStart: null,\n\t\thasDeclaration: null,\n\t\ttype: null,\n\t\tname: null,\n\t\tspecifiers: null\n\t};\n\n\tvar d = node.declaration;\n\n\tif (d) {\n\t\tresult.hasDeclaration = true;\n\t\tresult.value = source.slice(d.start, d.end);\n\t\tresult.valueStart = d.start;\n\n\t\t// Case 1: `export var foo = 'bar'`\n\t\tif (d.type === 'VariableDeclaration') {\n\t\t\tresult.type = 'varDeclaration';\n\t\t\tresult.name = d.declarations[0].id.name;\n\t\t}\n\n\t\t// Case 2: `export function foo () {...}`\n\t\telse if (d.type === 'FunctionDeclaration') {\n\t\t\t\tresult.type = 'namedFunction';\n\t\t\t\tresult.name = d.id.name;\n\t\t\t}\n\n\t\t\t// Case 3: `export class Foo {...}`\n\t\t\telse if (d.type === 'ClassDeclaration') {\n\t\t\t\t\tresult.type = 'namedClass';\n\t\t\t\t\tresult.name = d.id.name;\n\t\t\t\t}\n\t}\n\n\t// Case 9: `export { foo, bar };`\n\telse {\n\t\t\tresult.type = 'named';\n\t\t\tresult.specifiers = node.specifiers.map(function (s) {\n\t\t\t\treturn {\n\t\t\t\t\torigin: null, // filled in later by bundler\n\t\t\t\t\tname: s.local.name,\n\t\t\t\t\tas: s.exported.name\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\treturn result;\n}\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nfunction getUnscopedNames(mod) {\n\tvar unscoped = [],\n\t    importedNames,\n\t    scope;\n\n\tfunction imported(name) {\n\t\tif (!importedNames) {\n\t\t\timportedNames = {};\n\t\t\tmod.imports.forEach(function (i) {\n\t\t\t\t!i.passthrough && i.specifiers.forEach(function (s) {\n\t\t\t\t\timportedNames[s.as] = true;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn hasOwnProp.call(importedNames, name);\n\t}\n\n\twalk(mod.ast, {\n\t\tenter: function (node) {\n\t\t\t// we're only interested in references, not property names etc\n\t\t\tif (node._skip) return this.skip();\n\n\t\t\tif (node._scope) {\n\t\t\t\tscope = node._scope;\n\t\t\t}\n\n\t\t\tif (node.type === 'Identifier' && !scope.contains(node.name) && !imported(node.name) && ! ~unscoped.indexOf(node.name)) {\n\t\t\t\tunscoped.push(node.name);\n\t\t\t}\n\t\t},\n\n\t\tleave: function (node) {\n\t\t\tif (node.type === 'Program') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node._scope) {\n\t\t\t\tscope = scope.parent;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn unscoped;\n}\n\nfunction disallowConflictingImports(imports) {\n\tvar usedNames = {};\n\n\timports.forEach(function (x) {\n\t\tif (x.passthrough) return;\n\n\t\tif (x.as) {\n\t\t\tcheckName(x.as);\n\t\t} else {\n\t\t\tx.specifiers.forEach(checkSpecifier);\n\t\t}\n\t});\n\n\tfunction checkSpecifier(s) {\n\t\tcheckName(s.as);\n\t}\n\n\tfunction checkName(name) {\n\t\tif (hasOwnProp.call(usedNames, name)) {\n\t\t\tthrow new SyntaxError('Duplicated import (\\'' + name + '\\')');\n\t\t}\n\n\t\tusedNames[name] = true;\n\t}\n}\n\nvar RESERVED = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield'.split(' ');\nvar INVALID_CHAR = /[^a-zA-Z0-9_$]/g;\nvar INVALID_LEADING_CHAR = /[^a-zA-Z_$]/;\n\n/**\n * Generates a sanitized (i.e. valid identifier) name from a module ID\n * @param {string} id - a module ID, or part thereof\n * @returns {string}\n */\nfunction sanitize(name) {\n\tname = name.replace(INVALID_CHAR, '_');\n\n\tif (INVALID_LEADING_CHAR.test(name[0]) || ~RESERVED.indexOf(name)) {\n\t\tname = '_' + name;\n\t}\n\n\treturn name;\n}\n\nvar pathSplitRE = /\\/|\\\\/;\n\nfunction splitPath(path) {\n\treturn path.split(pathSplitRE);\n}\n\nvar SOURCEMAPPINGURL_REGEX = /^# sourceMappingURL=/;\nfunction getStandaloneModule(options) {\n\tvar code = undefined,\n\t    ast = undefined;\n\n\tif (typeof options.source === 'object') {\n\t\tcode = options.source.code;\n\t\tast = options.source.ast;\n\t} else {\n\t\tcode = options.source;\n\t}\n\n\tvar toRemove = [];\n\tvar comments = [];\n\n\tvar mod = {\n\t\tbody: new MagicString(code),\n\t\tast: ast || acorn.parse(code, {\n\t\t\tecmaVersion: 6,\n\t\t\tsourceType: 'module',\n\t\t\tonComment: function (block, text, start, end) {\n\t\t\t\t// sourceMappingURL comments should be removed\n\t\t\t\tif (!block && SOURCEMAPPINGURL_REGEX.test(text)) {\n\t\t\t\t\ttoRemove.push({ start: start, end: end });\n\t\t\t\t} else {\n\t\t\t\t\tcomments.push({ start: start, end: end });\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t};\n\n\ttoRemove.forEach(function (_ref) {\n\t\tvar start = _ref.start;\n\t\tvar end = _ref.end;\n\t\treturn mod.body.remove(start, end);\n\t});\n\n\tvar _findImportsAndExports = findImportsAndExports(mod.ast, code, comments);\n\n\tvar imports = _findImportsAndExports.imports;\n\tvar exports = _findImportsAndExports.exports;\n\tvar defaultExport = _findImportsAndExports.defaultExport;\n\n\tdisallowConflictingImports(imports);\n\n\tmod.imports = imports;\n\tmod.exports = exports;\n\tmod.defaultExport = defaultExport;\n\n\tvar conflicts = {};\n\n\tif (options.strict) {\n\t\tannotateAst(mod.ast, {\n\t\t\ttrackAssignments: null\n\t\t});\n\n\t\t// TODO there's probably an easier way to get this array\n\t\tObject.keys(mod.ast._declared).concat(getUnscopedNames(mod)).forEach(function (n) {\n\t\t\tconflicts[n] = true;\n\t\t});\n\t}\n\n\tdetermineImportNames(imports, options.getModuleName, conflicts);\n\n\treturn mod;\n}\n\nfunction determineImportNames(imports, userFn, usedNames) {\n\tvar nameById = {};\n\tvar inferredNames = {};\n\n\timports.forEach(function (x) {\n\t\tvar moduleId = x.path;\n\t\tvar name = undefined;\n\n\t\tmoduleId = x.path;\n\n\t\t// use existing value\n\t\tif (hasOwnProp.call(nameById, moduleId)) {\n\t\t\tx.name = nameById[moduleId];\n\t\t\treturn;\n\t\t}\n\n\t\t// if user supplied a function, defer to it\n\t\tif (userFn && (name = userFn(moduleId))) {\n\t\t\tname = sanitize(name);\n\n\t\t\tif (hasOwnProp.call(usedNames, name)) {\n\t\t\t\t// TODO write a test for this\n\t\t\t\tthrow new Error('Naming collision: module ' + moduleId + ' cannot be called ' + name);\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = splitPath(moduleId);\n\t\t\tvar i = undefined;\n\t\t\tvar prefix = '';\n\t\t\tvar candidate = undefined;\n\n\t\t\tdo {\n\t\t\t\ti = parts.length;\n\t\t\t\twhile (i-- > 0) {\n\t\t\t\t\tcandidate = prefix + sanitize(parts.slice(i).join('__'));\n\n\t\t\t\t\tif (!hasOwnProp.call(usedNames, candidate)) {\n\t\t\t\t\t\tname = candidate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix += '_';\n\t\t\t} while (!name);\n\t\t}\n\n\t\tusedNames[name] = true;\n\t\tnameById[moduleId] = name;\n\n\t\tx.name = name;\n\t});\n\n\t// use inferred names for default imports, wherever they\n\t// don't clash with path-based names\n\timports.forEach(function (x) {\n\t\tif (x.as && !hasOwnProp.call(usedNames, x.as)) {\n\t\t\tinferredNames[x.path] = x.as;\n\t\t}\n\t});\n\n\timports.forEach(function (x) {\n\t\tif (hasOwnProp.call(inferredNames, x.path)) {\n\t\t\tx.name = inferredNames[x.path];\n\t\t}\n\t});\n}\n\n/**\n * Resolves an importPath relative to the module that is importing it\n * @param {string} importPath - the (possibly relative) path of an imported module\n * @param {string} importerPath - the (relative to `base`) path of the importing module\n * @returns {string}\n */\nfunction resolveId(importPath, importerPath) {\n\tvar resolved, importerParts, importParts;\n\n\tif (importPath[0] !== '.') {\n\t\tresolved = importPath;\n\t} else {\n\t\timporterParts = splitPath(importerPath);\n\t\timportParts = splitPath(importPath);\n\n\t\tif (importParts[0] === '.') {\n\t\t\timportParts.shift();\n\t\t}\n\n\t\timporterParts.pop(); // get dirname\n\t\twhile (importParts[0] === '..') {\n\t\t\timportParts.shift();\n\t\t\timporterParts.pop();\n\t\t}\n\n\t\twhile (importParts[0] === '.') {\n\t\t\timportParts.shift();\n\t\t}\n\n\t\tresolved = importerParts.concat(importParts).join('/');\n\t}\n\n\treturn resolved;\n}\n\nfunction resolveAgainst(importerPath) {\n\treturn function (importPath) {\n\t\treturn resolveId(importPath, importerPath);\n\t};\n}\n\nfunction promiseSequence(arr, callback) {\n\tvar len = arr.length;\n\tvar results = new Array(len);\n\n\tvar promise = sander.Promise.resolve();\n\n\tfunction next(i) {\n\t\treturn promise.then(function () {\n\t\t\treturn callback(arr[i], i);\n\t\t}).then(function (result) {\n\t\t\treturn results[i] = result;\n\t\t});\n\t}\n\n\tvar i = undefined;\n\n\tfor (i = 0; i < len; i += 1) {\n\t\tpromise = next(i);\n\t}\n\n\treturn promise.then(function () {\n\t\treturn results;\n\t});\n}\n\n/**\n * Sorts an array of modules such that dependencies come before\n   their dependents, handling complex cases of cyclical dependencies\n * @param {object} entry - the bundle's 'entry module'\n * @returns {array} - the sorted module list\n */\nfunction sortModules(entry) {\n\tvar seen = {};\n\tvar ordered = [];\n\tvar hasCycles = undefined;\n\n\tvar strongDeps = {};\n\tvar stronglyDependsOn = {};\n\n\tfunction visit(mod) {\n\t\tvar id = mod.id;\n\n\t\tseen[id] = true;\n\n\t\tstrongDeps[id] = [];\n\t\tstronglyDependsOn[id] = {};\n\n\t\tmod.imports.forEach(function (x) {\n\t\t\tvar imported = x.module;\n\n\t\t\tif (imported.isExternal || imported.isSkipped) return;\n\n\t\t\t// if `mod` references a binding from `imported` at the top\n\t\t\t// level (i.e. outside function bodies), we say that `mod`\n\t\t\t// strongly depends on `imported. If two modules depend on\n\t\t\t// each other, this helps us order them such that if a\n\t\t\t// strongly depends on b, and b weakly depends on a, b\n\t\t\t// goes first\n\t\t\tif (referencesAtTopLevel(mod, imported)) {\n\t\t\t\tstrongDeps[id].push(imported);\n\t\t\t}\n\n\t\t\tif (hasOwnProp.call(seen, imported.id)) {\n\t\t\t\t// we need to prevent an infinite loop, and note that\n\t\t\t\t// we need to check for strong/weak dependency relationships\n\t\t\t\thasCycles = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvisit(imported);\n\t\t});\n\n\t\t// add second (and third...) order dependencies\n\t\tfunction addStrongDependencies(dependency) {\n\t\t\tif (hasOwnProp.call(stronglyDependsOn[id], dependency.id)) return;\n\n\t\t\tstronglyDependsOn[id][dependency.id] = true;\n\t\t\tstrongDeps[dependency.id].forEach(addStrongDependencies);\n\t\t}\n\n\t\tstrongDeps[id].forEach(addStrongDependencies);\n\n\t\tordered.push(mod);\n\t}\n\n\tvisit(entry);\n\n\tvar unordered = undefined;\n\n\tif (hasCycles) {\n\t\tunordered = ordered;\n\t\tordered = [];\n\n\t\t// unordered is actually semi-ordered, as [ fewer dependencies ... more dependencies ]\n\t\tunordered.forEach(function (x) {\n\t\t\t// ensure strong dependencies of x that don't strongly depend on x go first\n\t\t\tstrongDeps[x.id].forEach(place);\n\n\t\t\tfunction place(dep) {\n\t\t\t\tif (!stronglyDependsOn[dep.id][x.id] && ! ~ordered.indexOf(dep)) {\n\t\t\t\t\tstrongDeps[dep.id].forEach(place);\n\t\t\t\t\tordered.push(dep);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (! ~ordered.indexOf(x)) {\n\t\t\t\tordered.push(x);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn ordered;\n}\n\nfunction referencesAtTopLevel(a, b) {\n\tvar bindings = [];\n\n\t// find out which bindings a imports from b\n\tvar i = a.imports.length;\n\twhile (i--) {\n\t\tif (a.imports[i].module === b) {\n\t\t\tbindings.push.apply(bindings, a.imports[i].specifiers.map(function (x) {\n\t\t\t\treturn x.as;\n\t\t\t}));\n\t\t}\n\t}\n\n\t// see if any of those bindings are referenced at the top level\n\tvar referencedAtTopLevel = false;\n\n\twalk(a.ast, {\n\t\tenter: function (node) {\n\t\t\tif (/^Import/.test(node.type) || node._scope && node._scope.parent) {\n\t\t\t\treturn this.skip();\n\t\t\t}\n\n\t\t\tif (node.type === 'Identifier' && ~bindings.indexOf(node.name)) {\n\t\t\t\treferencedAtTopLevel = true;\n\t\t\t\tthis.abort();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn referencedAtTopLevel;\n}\n\n/**\n * Discovers 'chains' within a bundle - e.g. `import { foo } from 'foo'`\n   may be equivalent to `import { bar } from 'bar'`, if foo.js imports `bar`\n   and re-exports it as `foo`. Where applicable, import/export specifiers\n   are augmented with an `origin: { module, name }` property\n * @param {array} modules - the bundle's array of modules\n * @param {object} moduleLookup - modules indexed by their ID\n */\nfunction resolveChains(modules, moduleLookup) {\n\tvar chains = {};\n\n\t// First pass - resolving intra-module chains\n\tmodules.forEach(function (mod) {\n\t\tvar origin = {};\n\n\t\tmod.imports.forEach(function (x) {\n\t\t\tvar imported = x.module;\n\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tif (s.isBatch) {\n\t\t\t\t\t// tell that module that it needs to export an object full of getters\n\t\t\t\t\timported._exportsNamespace = true;\n\t\t\t\t\treturn; // TODO can batch imports be chained?\n\t\t\t\t}\n\n\t\t\t\torigin[s.as] = s.name + '@' + imported.id;\n\t\t\t});\n\t\t});\n\n\t\tmod.exports.forEach(function (x) {\n\t\t\tif (!x.specifiers) return;\n\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tif (hasOwnProp.call(origin, s.name)) {\n\t\t\t\t\tchains[s.as + '@' + mod.id] = origin[s.name];\n\t\t\t\t} else if (s.as !== s.name) {\n\t\t\t\t\tchains[s.as + '@' + mod.id] = s.name + '@' + mod.id;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n\n\t// Second pass - assigning origins to specifiers\n\tmodules.forEach(function (mod) {\n\t\tmod.imports.forEach(function (x) {\n\t\t\tvar imported = x.module;\n\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tif (s.isBatch) {\n\t\t\t\t\treturn; // TODO can batch imports be chained?\n\t\t\t\t}\n\n\t\t\t\tsetOrigin(s, s.name + '@' + imported.id, chains, moduleLookup);\n\t\t\t});\n\t\t});\n\n\t\tmod.exports.forEach(function (x) {\n\t\t\tif (!x.specifiers) return;\n\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tsetOrigin(s, s.as + '@' + mod.id, chains, moduleLookup);\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction setOrigin(specifier, hash, chains, moduleLookup) {\n\tvar isChained = undefined;\n\n\twhile (hasOwnProp.call(chains, hash)) {\n\t\thash = chains[hash];\n\t\tisChained = true;\n\t}\n\n\tif (isChained) {\n\t\tvar _hash$split = hash.split('@');\n\n\t\tvar _name = _hash$split[0];\n\t\tvar moduleId = _hash$split[1];\n\n\t\tspecifier.origin = { module: moduleLookup[moduleId], name: _name };\n\t}\n}\n\n// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n// we add `exports` to this list, to avoid conflicts\nvar builtins = 'Array ArrayBuffer DataView Date Error EvalError Float32Array Float64Array Function Generator GeneratorFunction Infinity Int16Array Int32Array Int8Array InternalError Intl Iterator JSON Map Math NaN Number Object ParallelArray Promise Proxy RangeError ReferenceError Reflect RegExp Set StopIteration String Symbol SyntaxError TypeError TypedArray URIError Uint16Array Uint32Array Uint8Array Uint8ClampedArray WeakMap WeakSet decodeURI decodeURIComponent encodeURI encodeURIComponent escape eval exports isFinite isNaN null parseFloat parseInt undefined unescape uneval'.split(' ');\n\nvar populateModuleNames = getUniqueNames;\nfunction getUniqueNames(bundle) {\n\tvar modules = bundle.modules;\n\tvar externalModules = bundle.externalModules;\n\n\tvar userNames = bundle.names;\n\tvar names = {};\n\n\tvar used = modules.reduce(function (declared, mod) {\n\t\tvar defaultExport = mod.defaultExport;\n\t\tvar defaultExportName = defaultExport && !defaultExport.unsafe && defaultExport.type === 'expression' && defaultExport.node.declaration && defaultExport.node.declaration.type === 'Identifier' && defaultExport.node.declaration.name;\n\n\t\tObject.keys(mod.ast._declared).forEach(function (x) {\n\t\t\t// special case - `export default foo`\n\t\t\tif (x === defaultExportName) return;\n\t\t\tdeclared[x] = true;\n\t\t});\n\t\treturn declared;\n\t}, {});\n\n\t// copy builtins\n\tbuiltins.forEach(function (n) {\n\t\treturn used[n] = true;\n\t});\n\n\t// copy user-specified names\n\tif (userNames) {\n\t\tObject.keys(userNames).forEach(function (id) {\n\t\t\tnames[id] = userNames[id];\n\t\t\tused[userNames[id]] = true;\n\t\t});\n\t}\n\n\t// infer names from default imports - e.g. with `import _ from './utils'`,\n\t// use '_' instead of generating a name from 'utils'\n\tfunction inferName(x) {\n\t\tif (x.isDefault && !hasOwnProp.call(names, x.module.id) && !hasOwnProp.call(used, x.as)) {\n\t\t\tnames[x.module.id] = x.as;\n\t\t\tused[x.as] = true;\n\t\t}\n\t}\n\tmodules.forEach(function (mod) {\n\t\tmod.imports.forEach(inferName);\n\t});\n\n\t// for the rest, make names as compact as possible without\n\t// introducing conflicts\n\tmodules.concat(externalModules).forEach(function (mod) {\n\t\t// is this already named?\n\t\tif (hasOwnProp.call(names, mod.id)) {\n\t\t\tmod.name = names[mod.id];\n\t\t\treturn;\n\t\t}\n\n\t\tvar name = undefined;\n\t\tvar parts = splitPath(mod.id);\n\t\tvar i = parts.length;\n\n\t\twhile (i--) {\n\t\t\tname = sanitize(parts.slice(i).join('_'));\n\n\t\t\tif (!hasOwnProp.call(used, name)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (hasOwnProp.call(used, name)) {\n\t\t\tname = '_' + name;\n\t\t}\n\n\t\tused[name] = true;\n\t\tmod.name = name;\n\t});\n\n\treturn names;\n}\n\nfunction populateExternalModuleImports(bundle) {\n\tbundle.modules.forEach(function (mod) {\n\t\tmod.imports.forEach(function (x) {\n\t\t\tvar externalModule = x.module;\n\n\t\t\tif (!externalModule.isExternal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tif (s.isDefault) {\n\t\t\t\t\texternalModule.needsDefault = true;\n\t\t\t\t} else {\n\t\t\t\t\texternalModule.needsNamed = true;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction getRenamedImports(mod) {\n\tvar renamed = [];\n\n\tmod.imports.forEach(function (x) {\n\t\tif (x.specifiers) {\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tif (s.name !== s.as && ! ~renamed.indexOf(s.name)) {\n\t\t\t\t\trenamed.push(s.name);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\treturn renamed;\n}\n\nfunction topLevelScopeConflicts(bundle) {\n\tvar conflicts = {};\n\tvar inBundle = {};\n\tvar importNames = bundle.externalModules.map(getName);\n\n\tbundle.modules.forEach(function (mod) {\n\t\tvar names = builtins\n\n\t\t// all top defined identifiers are in top scope\n\t\t.concat(mod.ast._topLevelNames)\n\n\t\t// all unattributed identifiers could collide with top scope\n\t\t.concat(getUnscopedNames(mod)).concat(importNames).concat(getRenamedImports(mod));\n\n\t\tif (mod._exportsNamespace) {\n\t\t\tconflicts[mod.name] = true;\n\t\t}\n\n\t\t// merge this module's top scope with bundle top scope\n\t\tnames.forEach(function (name) {\n\t\t\tif (hasOwnProp.call(inBundle, name)) {\n\t\t\t\tconflicts[name] = true;\n\t\t\t} else {\n\t\t\t\tinBundle[name] = true;\n\t\t\t}\n\t\t});\n\t});\n\n\treturn conflicts;\n}\n\n/**\n * Figures out which identifiers need to be rewritten within\n   a bundle to avoid conflicts\n * @param {object} bundle - the bundle\n * @returns {object}\n */\nfunction populateIdentifierReplacements(bundle) {\n\t// first, discover conflicts\n\tvar conflicts = topLevelScopeConflicts(bundle);\n\n\t// then figure out what identifiers need to be created\n\t// for default exports\n\tbundle.modules.forEach(function (mod) {\n\t\tvar x = mod.defaultExport;\n\n\t\tif (x) {\n\t\t\tvar result = undefined;\n\n\t\t\tif (x.hasDeclaration && x.name) {\n\t\t\t\tresult = hasOwnProp.call(conflicts, x.name) || otherModulesDeclare(mod, x.name) ? mod.name + '__' + x.name : x.name;\n\t\t\t} else {\n\t\t\t\tresult = hasOwnProp.call(conflicts, mod.name) || x.value !== mod.name && ~mod.ast._topLevelNames.indexOf(mod.name) || otherModulesDeclare(mod, mod.name) ? mod.name + '__default' : mod.name;\n\t\t\t}\n\n\t\t\tmod.identifierReplacements['default'] = result;\n\t\t}\n\t});\n\n\t// then determine which existing identifiers\n\t// need to be replaced\n\tbundle.modules.forEach(function (mod) {\n\t\tvar moduleIdentifiers = mod.identifierReplacements;\n\n\t\tmod.ast._topLevelNames.forEach(function (n) {\n\t\t\tmoduleIdentifiers[n] = hasOwnProp.call(conflicts, n) ? mod.name + '__' + n : n;\n\t\t});\n\n\t\tmod.imports.forEach(function (x) {\n\t\t\tif (x.passthrough) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar imported = x.module;\n\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tvar replacement = undefined;\n\n\t\t\t\tif (s.isBatch) {\n\t\t\t\t\treplacement = x.module.name;\n\t\t\t\t} else {\n\t\t\t\t\tvar _mod = undefined;\n\t\t\t\t\tvar specifierName = undefined;\n\n\t\t\t\t\tif (s.origin) {\n\t\t\t\t\t\t// chained bindings\n\t\t\t\t\t\t_mod = s.origin.module;\n\t\t\t\t\t\tspecifierName = s.origin.name;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_mod = imported;\n\t\t\t\t\t\tspecifierName = s.name;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar moduleName = _mod && _mod.name;\n\n\t\t\t\t\tif (specifierName === 'default') {\n\t\t\t\t\t\t// if it's an external module, always use __default if the\n\t\t\t\t\t\t// bundle also uses named imports\n\t\t\t\t\t\tif (imported.isExternal) {\n\t\t\t\t\t\t\treplacement = imported.needsNamed ? moduleName + '__default' : moduleName;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO We currently need to check for the existence of `mod`, because modules\n\t\t\t\t\t\t// can be skipped. Would be better to replace skipped modules with dummies\n\t\t\t\t\t\t// - see https://github.com/Rich-Harris/esperanto/issues/32\n\t\t\t\t\t\telse if (_mod && !_mod.isSkipped) {\n\t\t\t\t\t\t\t\treplacement = _mod.identifierReplacements['default'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!imported.isExternal) {\n\t\t\t\t\t\treplacement = hasOwnProp.call(conflicts, specifierName) ? moduleName + '__' + specifierName : specifierName;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplacement = moduleName + '.' + specifierName;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (replacement !== s.as) {\n\t\t\t\t\tmoduleIdentifiers[s.as] = replacement;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n\n\tfunction otherModulesDeclare(mod, replacement) {\n\t\tvar i, otherMod;\n\n\t\ti = bundle.modules.length;\n\t\twhile (i--) {\n\t\t\totherMod = bundle.modules[i];\n\n\t\t\tif (mod === otherMod) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (hasOwnProp.call(otherMod.ast._declared, replacement)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction resolveExports(bundle) {\n\tvar bundleExports = {};\n\n\tbundle.entryModule.exports.forEach(function (x) {\n\t\tif (x.specifiers) {\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tvar module = undefined;\n\t\t\t\tvar name = undefined;\n\n\t\t\t\tif (s.origin) {\n\t\t\t\t\tmodule = s.origin.module;\n\t\t\t\t\tname = s.origin.name;\n\t\t\t\t} else {\n\t\t\t\t\tmodule = bundle.entryModule;\n\t\t\t\t\tname = s.name;\n\t\t\t\t}\n\n\t\t\t\taddExport(module, name, s.as);\n\t\t\t});\n\t\t} else if (!x.isDefault && x.name) {\n\t\t\taddExport(bundle.entryModule, x.name, x.name);\n\t\t}\n\t});\n\n\tfunction addExport(module, name, as) {\n\t\tif (!bundleExports[module.id]) {\n\t\t\tbundleExports[module.id] = {};\n\t\t}\n\n\t\tbundleExports[module.id][name] = as;\n\t}\n\n\treturn bundleExports;\n}\n\n/**\n * Scans an array of imports, and determines which identifiers\n   are readonly, and which cannot be assigned to. For example\n   you cannot `import foo from 'foo'` then do `foo = 42`, nor\n   can you `import * as foo from 'foo'` then do `foo.answer = 42`\n * @param {array} imports - the array of imports\n * @returns {array} [ importedBindings, importedNamespaces ]\n */\nfunction getReadOnlyIdentifiers(imports) {\n\tvar importedBindings = {},\n\t    importedNamespaces = {};\n\n\timports.forEach(function (x) {\n\t\tif (x.passthrough) return;\n\n\t\tx.specifiers.forEach(function (s) {\n\t\t\tif (s.isBatch) {\n\t\t\t\timportedNamespaces[s.as] = true;\n\t\t\t} else {\n\t\t\t\timportedBindings[s.as] = true;\n\t\t\t}\n\t\t});\n\t});\n\n\treturn [importedBindings, importedNamespaces];\n}\n\nvar bindingMessage = 'Cannot reassign imported binding ',\n    namespaceMessage = 'Cannot reassign imported binding of namespace ';\nfunction disallowIllegalReassignment(node, importedBindings, importedNamespaces, scope) {\n\tvar assignee = undefined,\n\t    isNamespaceAssignment = undefined;\n\n\tif (node.type === 'AssignmentExpression') {\n\t\tassignee = node.left;\n\t} else if (node.type === 'UpdateExpression') {\n\t\tassignee = node.argument;\n\t} else {\n\t\treturn; // not an assignment\n\t}\n\n\tif (assignee.type === 'MemberExpression') {\n\t\tassignee = assignee.object;\n\t\tisNamespaceAssignment = true;\n\t}\n\n\tif (assignee.type !== 'Identifier') {\n\t\treturn; // not assigning to a binding\n\t}\n\n\tvar name = assignee.name;\n\n\tif (hasOwnProp.call(isNamespaceAssignment ? importedNamespaces : importedBindings, name) && !scope.contains(name)) {\n\t\tthrow new Error((isNamespaceAssignment ? namespaceMessage : bindingMessage) + '`' + name + '`');\n\t}\n}\n\nfunction replaceIdentifiers(body, node, identifierReplacements, scope) {\n\tvar name = node.name;\n\tvar replacement = hasOwnProp.call(identifierReplacements, name) && identifierReplacements[name];\n\n\t// TODO unchanged identifiers shouldn't have got this far -\n\t// remove the `replacement !== name` safeguard once that's the case\n\tif (replacement && replacement !== name && !scope.contains(name, true)) {\n\t\t// rewrite\n\t\tbody.replace(node.start, node.end, replacement);\n\t}\n}\n\nfunction rewriteExportAssignments(body, node, parent, exports, scope, capturedUpdates) {\n\tvar assignee = undefined;\n\n\tif (node.type === 'AssignmentExpression') {\n\t\tassignee = node.left;\n\t} else if (node.type === 'UpdateExpression') {\n\t\tassignee = node.argument;\n\t} else {\n\t\treturn; // not an assignment\n\t}\n\n\tif (assignee.type !== 'Identifier') {\n\t\treturn;\n\t}\n\n\tvar name = assignee.name;\n\n\tif (scope.contains(name, true)) {\n\t\treturn; // shadows an export\n\t}\n\n\tif (exports && hasOwnProp.call(exports, name)) {\n\t\tvar exportAs = exports[name];\n\n\t\tif (!!capturedUpdates) {\n\t\t\tcapturedUpdates.push({ name: name, exportAs: exportAs });\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - increment/decrement operators\n\t\tif (node.operator === '++' || node.operator === '--') {\n\t\t\tvar prefix = '';\n\t\t\tvar suffix = ', exports.' + exportAs + ' = ' + name;\n\t\t\tif (parent.type !== 'ExpressionStatement') {\n\t\t\t\tif (!node.prefix) {\n\t\t\t\t\tsuffix += ', ' + name + ' ' + (node.operator === '++' ? '-' : '+') + ' 1';\n\t\t\t\t}\n\t\t\t\tprefix += '( ';\n\t\t\t\tsuffix += ' )';\n\t\t\t}\n\t\t\tbody.insert(node.start, prefix);\n\t\t\tbody.insert(node.end, suffix);\n\t\t} else {\n\t\t\tbody.insert(node.start, 'exports.' + exportAs + ' = ');\n\t\t}\n\t}\n}\n\nfunction traverseAst(ast, body, identifierReplacements, importedBindings, importedNamespaces, exportNames) {\n\tvar scope = ast._scope;\n\tvar blockScope = ast._blockScope;\n\tvar capturedUpdates = null;\n\tvar previousCapturedUpdates = null;\n\n\twalk(ast, {\n\t\tenter: function (node, parent) {\n\t\t\t// we're only interested in references, not property names etc\n\t\t\tif (node._skip) return this.skip();\n\n\t\t\tif (node._scope) {\n\t\t\t\tscope = node._scope;\n\t\t\t} else if (node._blockScope) {\n\t\t\t\tblockScope = node._blockScope;\n\t\t\t}\n\n\t\t\t// Special case: if you have a variable declaration that updates existing\n\t\t\t// bindings as a side-effect, e.g. `var a = b++`, where `b` is an exported\n\t\t\t// value, we can't simply append `exports.b = b` to the update (as we\n\t\t\t// normally would) because that would be syntactically invalid. Instead,\n\t\t\t// we capture the change and update the export (and any others) after the\n\t\t\t// variable declaration\n\t\t\tif (node.type === 'VariableDeclaration') {\n\t\t\t\tpreviousCapturedUpdates = capturedUpdates;\n\t\t\t\tcapturedUpdates = [];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdisallowIllegalReassignment(node, importedBindings, importedNamespaces, scope);\n\n\t\t\t// Rewrite assignments to exports inside functions, to keep bindings live.\n\t\t\t// This call may mutate `capturedUpdates`, which is used elsewhere\n\t\t\tif (scope !== ast._scope) {\n\t\t\t\trewriteExportAssignments(body, node, parent, exportNames, scope, capturedUpdates);\n\t\t\t}\n\n\t\t\tif (node.type === 'Identifier' && parent.type !== 'FunctionExpression') {\n\t\t\t\treplaceIdentifiers(body, node, identifierReplacements, scope);\n\t\t\t}\n\n\t\t\t// Replace top-level this with undefined ES6 8.1.1.5.4\n\t\t\tif (node.type === 'ThisExpression' && node._topLevel) {\n\t\t\t\tbody.replace(node.start, node.end, 'undefined');\n\t\t\t}\n\t\t},\n\n\t\tleave: function (node) {\n\t\t\t// Special case - see above\n\t\t\tif (node.type === 'VariableDeclaration') {\n\t\t\t\tif (capturedUpdates.length) {\n\t\t\t\t\tbody.insert(node.end, capturedUpdates.map(exportCapturedUpdate).join(''));\n\t\t\t\t}\n\n\t\t\t\tcapturedUpdates = previousCapturedUpdates;\n\t\t\t}\n\n\t\t\tif (node._scope) {\n\t\t\t\tscope = scope.parent;\n\t\t\t} else if (node._blockScope) {\n\t\t\t\tblockScope = blockScope.parent;\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction exportCapturedUpdate(c) {\n\treturn ' exports.' + c.exportAs + ' = ' + c.name + ';';\n}\n\nvar transformBody__default = transformBody__transformBody;\nfunction transformBody__transformBody(bundle, mod, body) {\n\tvar identifierReplacements = mod.identifierReplacements;\n\n\tvar _getReadOnlyIdentifiers = getReadOnlyIdentifiers(mod.imports);\n\n\tvar importedBindings = _getReadOnlyIdentifiers[0];\n\tvar importedNamespaces = _getReadOnlyIdentifiers[1];\n\n\tvar exportNames = hasOwnProp.call(bundle.exports, mod.id) && bundle.exports[mod.id];\n\n\ttraverseAst(mod.ast, body, identifierReplacements, importedBindings, importedNamespaces, exportNames);\n\n\t// Remove import statements\n\tmod.imports.forEach(function (x) {\n\t\tif (!x.passthrough) {\n\t\t\tbody.remove(x.start, x.next);\n\t\t}\n\t});\n\n\tvar shouldExportEarly = {};\n\n\t// Remove export statements\n\tmod.exports.forEach(function (x) {\n\t\tvar name;\n\n\t\tif (x.isDefault) {\n\t\t\tif (x.type === 'namedFunction' || x.type === 'namedClass') {\n\t\t\t\t// if you have a default export like\n\t\t\t\t//\n\t\t\t\t//     export default function foo () {...}\n\t\t\t\t//\n\t\t\t\t// you need to rewrite it as\n\t\t\t\t//\n\t\t\t\t//     function foo () {...}\n\t\t\t\t//     exports.default = foo;\n\t\t\t\t//\n\t\t\t\t// as the `foo` reference may be used elsewhere\n\n\t\t\t\t// remove the `export default `, keep the rest\n\t\t\t\tbody.remove(x.start, x.valueStart);\n\t\t\t} else if (x.node.declaration && (name = x.node.declaration.name)) {\n\t\t\t\tif (name === identifierReplacements['default']) {\n\t\t\t\t\tbody.remove(x.start, x.end);\n\t\t\t\t} else {\n\t\t\t\t\tvar original = hasOwnProp.call(identifierReplacements, name) ? identifierReplacements[name] : name;\n\t\t\t\t\tbody.replace(x.start, x.end, 'var ' + identifierReplacements['default'] + ' = ' + original + ';');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbody.replace(x.start, x.valueStart, 'var ' + identifierReplacements['default'] + ' = ');\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (x.hasDeclaration) {\n\t\t\tif (x.type === 'namedFunction') {\n\t\t\t\tshouldExportEarly[x.name] = true; // TODO what about `function foo () {}; export { foo }`?\n\t\t\t}\n\n\t\t\tbody.remove(x.start, x.valueStart);\n\t\t} else {\n\t\t\tbody.remove(x.start, x.next);\n\t\t}\n\t});\n\n\t// If this module exports a namespace - i.e. another module does\n\t// `import * from 'foo'` - then we need to make all this module's\n\t// exports available, using Object.defineProperty\n\tvar indentStr = body.getIndentString();\n\tif (mod._exportsNamespace) {\n\t\t(function () {\n\t\t\tvar namespaceExportBlock = 'var ' + mod.name + ' = {\\n',\n\t\t\t    namespaceExports = [];\n\n\t\t\tmod.exports.forEach(function (x) {\n\t\t\t\tif (x.hasDeclaration) {\n\t\t\t\t\tnamespaceExports.push(indentStr + ('get ' + x.name + ' () { return ' + identifierReplacements[x.name] + '; }'));\n\t\t\t\t} else if (x.isDefault) {\n\t\t\t\t\tnamespaceExports.push(indentStr + ('get default () { return ' + identifierReplacements['default'] + '; }'));\n\t\t\t\t} else {\n\t\t\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\t\t\tvar original = hasOwnProp.call(identifierReplacements, s.name) ? identifierReplacements[s.name] : s.name;\n\t\t\t\t\t\tnamespaceExports.push(indentStr + ('get ' + s.as + ' () { return ' + original + '; }'));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tnamespaceExportBlock += namespaceExports.join(',\\n') + '\\n};\\n\\n';\n\n\t\t\tbody.prepend(namespaceExportBlock);\n\t\t})();\n\t}\n\n\t// If this module is responsible for one of the bundle's exports\n\t// (it doesn't have to be the entry module, which could re-export\n\t// a binding from another module), we write exports here\n\tif (exportNames) {\n\t\t(function () {\n\t\t\tvar exportBlock = [];\n\n\t\t\tObject.keys(exportNames).forEach(function (name) {\n\t\t\t\tvar exportAs = exportNames[name];\n\t\t\t\texportBlock.push('exports.' + exportAs + ' = ' + identifierReplacements[name] + ';');\n\t\t\t});\n\n\t\t\tif (exportBlock.length) {\n\t\t\t\tbody.trim().append('\\n\\n' + exportBlock.join('\\n'));\n\t\t\t}\n\t\t})();\n\t}\n\n\treturn body.trim();\n}\n\nfunction combine(bundle) {\n\tbundle.body = new MagicString.Bundle({\n\t\tseparator: '\\n\\n'\n\t});\n\n\t// give each module in the bundle a unique name\n\tpopulateModuleNames(bundle);\n\n\t// determine which specifiers are imported from\n\t// external modules\n\tpopulateExternalModuleImports(bundle);\n\n\t// determine which identifiers need to be replaced\n\t// inside this bundle\n\tpopulateIdentifierReplacements(bundle);\n\n\tbundle.exports = resolveExports(bundle);\n\n\tbundle.modules.forEach(function (mod) {\n\t\t// verify that this module doesn't import non-exported identifiers\n\t\tmod.imports.forEach(function (x) {\n\t\t\tvar imported = x.module;\n\n\t\t\tif (imported.isExternal || imported.isSkipped || x.isBatch) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tif (!imported.doesExport[s.name]) {\n\t\t\t\t\tthrow new Error('Module \\'' + imported.id + '\\' does not export \\'' + s.name + '\\' (imported by \\'' + mod.id + '\\')');\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tbundle.body.addSource({\n\t\t\tfilename: mod.path,\n\t\t\tcontent: transformBody__default(bundle, mod, mod.body),\n\t\t\tindentExclusionRanges: mod.ast._templateLiteralRanges\n\t\t});\n\t});\n}\n\nfunction getModule(mod) {\n\tmod.body = new MagicString(mod.code);\n\n\tvar toRemove = [];\n\tvar comments = [];\n\n\ttry {\n\t\tmod.ast = mod.ast || acorn.parse(mod.code, {\n\t\t\tecmaVersion: 6,\n\t\t\tsourceType: 'module',\n\t\t\tonComment: function (block, text, start, end) {\n\t\t\t\t// sourceMappingURL comments should be removed\n\t\t\t\tif (!block && /^# sourceMappingURL=/.test(text)) {\n\t\t\t\t\ttoRemove.push({ start: start, end: end });\n\t\t\t\t} else {\n\t\t\t\t\tcomments.push({ start: start, end: end });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (err) {\n\t\t// If there's a parse error, attach file info\n\t\t// before throwing the error\n\t\tif (err.loc) {\n\t\t\terr.file = mod.path;\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\t// remove sourceMappingURL comments\n\ttoRemove.forEach(function (_ref) {\n\t\tvar start = _ref.start;\n\t\tvar end = _ref.end;\n\t\treturn mod.body.remove(start, end);\n\t});\n\n\tvar _findImportsAndExports = findImportsAndExports(mod.ast, mod.code, comments);\n\n\tvar imports = _findImportsAndExports.imports;\n\tvar exports = _findImportsAndExports.exports;\n\tvar defaultExport = _findImportsAndExports.defaultExport;\n\n\tdisallowConflictingImports(imports);\n\n\tmod.imports = imports;\n\tmod.exports = exports;\n\tmod.defaultExport = defaultExport;\n\n\tvar defaultExportIdentifier = defaultExport && defaultExport.type === 'expression' && defaultExport.node.declaration && defaultExport.node.declaration.type === 'Identifier' && defaultExport.node.declaration;\n\n\t// if the default export is an expression like `export default foo`, we\n\t// can *probably* just use `foo` to refer to said export throughout the\n\t// bundle. Tracking assignments to `foo` allows us to be sure that that's\n\t// the case (i.e. that the module doesn't assign a different value to foo\n\t// after it's been exported)\n\tannotateAst(mod.ast, {\n\t\ttrackAssignments: defaultExportIdentifier\n\t});\n\n\tif (defaultExportIdentifier && defaultExportIdentifier._assignments) {\n\t\tvar i = defaultExportIdentifier._assignments.length;\n\t\twhile (i--) {\n\t\t\tvar assignment = defaultExportIdentifier._assignments[i];\n\n\t\t\t// if either a) the assignment happens inside a function body, or\n\t\t\t// b) it happens after the `export default ...`, then it's unsafe to\n\t\t\t// use the identifier, and we need to essentially do `var _foo = foo`\n\t\t\tif (assignment.scope.parent || assignment.node.start > defaultExport.start) {\n\t\t\t\tdefaultExport.unsafe = true; // TODO better property name than 'unsafe'\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// identifiers to replace within this module\n\t// (gets filled in later, once bundle is combined)\n\tmod.identifierReplacements = {};\n\n\t// collect exports by name, for quick lookup when verifying\n\t// that this module exports a given identifier\n\tmod.doesExport = {};\n\n\texports.forEach(function (x) {\n\t\tif (x.isDefault) {\n\t\t\tmod.doesExport['default'] = true;\n\t\t} else if (x.name) {\n\t\t\tmod.doesExport[x.name] = true;\n\t\t} else if (x.specifiers) {\n\t\t\tx.specifiers.forEach(function (s) {\n\t\t\t\tmod.doesExport[s.as] = true;\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error('Unexpected export type');\n\t\t}\n\t});\n\n\treturn mod;\n}\n\nfunction getBundle(options) {\n\tvar entry = options.entry.replace(/\\.js$/, '');\n\tvar userModules = options.modules || {};\n\tvar modules = [];\n\tvar moduleLookup = {};\n\tvar promiseByPath = {};\n\tvar skip = options.skip;\n\tvar names = options.names;\n\tvar base = (options.base ? _path.resolve(options.base) : process.cwd()) + '/';\n\tvar externalModules = [];\n\tvar externalModuleLookup = {};\n\n\tif (!entry.indexOf(base)) {\n\t\tentry = entry.substring(base.length);\n\t}\n\n\t// resolve user module paths\n\toptions.modules && Object.keys(options.modules).forEach(function (relativePath) {\n\t\tuserModules[_path.resolve(base, relativePath)] = options.modules[relativePath];\n\t});\n\n\tvar cyclicalModules = [];\n\n\treturn resolvePath(base, userModules, entry, null).then(function (absolutePath) {\n\t\treturn fetchModule(entry, absolutePath).then(function (entryModule) {\n\t\t\treturn sander.Promise.all(cyclicalModules).then(function () {\n\t\t\t\t// if the bundle contains cyclical modules,\n\t\t\t\t// we may need to sort it again\n\t\t\t\tif (cyclicalModules.length) {\n\t\t\t\t\tmodules = sortModules(entryModule);\n\t\t\t\t}\n\n\t\t\t\tvar bundle = {\n\t\t\t\t\tentryModule: entryModule,\n\t\t\t\t\tmodules: modules,\n\t\t\t\t\texternalModules: externalModules,\n\t\t\t\t\tnames: names\n\t\t\t\t};\n\n\t\t\t\tresolveChains(modules, moduleLookup);\n\t\t\t\tcombine(bundle);\n\n\t\t\t\treturn bundle;\n\t\t\t});\n\t\t});\n\t}, function (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\tthrow new Error('Could not find entry module (' + entry + ')');\n\t\t}\n\n\t\tthrow err;\n\t});\n\n\tfunction fetchModule(moduleId, absolutePath) {\n\t\tif (!hasOwnProp.call(promiseByPath, absolutePath)) {\n\t\t\tpromiseByPath[absolutePath] = (hasOwnProp.call(userModules, absolutePath) ? sander.Promise.resolve(userModules[absolutePath]) : sander.readFile(absolutePath).then(String)).then(function (source) {\n\t\t\t\tvar code = undefined,\n\t\t\t\t    ast = undefined;\n\n\t\t\t\t// normalise\n\t\t\t\tif (typeof source === 'object') {\n\t\t\t\t\tcode = source.code;\n\t\t\t\t\tast = source.ast;\n\t\t\t\t} else {\n\t\t\t\t\tcode = source;\n\t\t\t\t\tast = null;\n\t\t\t\t}\n\n\t\t\t\tif (options.transform) {\n\t\t\t\t\tcode = options.transform(code, absolutePath);\n\n\t\t\t\t\tif (typeof code !== 'string' && !isThenable(code)) {\n\t\t\t\t\t\tthrow new Error('transform should return String or Promise');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar module = getModule({\n\t\t\t\t\tid: moduleId,\n\t\t\t\t\tpath: absolutePath,\n\t\t\t\t\tcode: code,\n\t\t\t\t\tast: ast\n\t\t\t\t});\n\n\t\t\t\tmoduleLookup[moduleId] = module;\n\n\t\t\t\treturn promiseSequence(module.imports, function (x) {\n\t\t\t\t\tvar id = resolveId(x.path, module.path).replace(base.replace(/\\\\/g, '/'), '');\n\n\t\t\t\t\tif (id === moduleId) {\n\t\t\t\t\t\tthrow new Error('A module (' + moduleId + ') cannot import itself');\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some modules can be skipped\n\t\t\t\t\tif (skip && ~skip.indexOf(id)) {\n\t\t\t\t\t\tvar skippedModule = {\n\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\tisSkipped: true\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tx.module = skippedModule;\n\t\t\t\t\t\treturn skippedModule;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolvePath(base, userModules, id, absolutePath, options.resolvePath).then(function (absolutePath) {\n\t\t\t\t\t\tvar promise = hasOwnProp.call(promiseByPath, absolutePath) && promiseByPath[absolutePath];\n\t\t\t\t\t\tvar cyclical = !!promise;\n\n\t\t\t\t\t\tif (cyclical) {\n\t\t\t\t\t\t\t// ensure all modules are set before we\n\t\t\t\t\t\t\t// create the bundle...\n\t\t\t\t\t\t\tcyclicalModules.push(promise.then(function (module) {\n\t\t\t\t\t\t\t\treturn x.module = module;\n\t\t\t\t\t\t\t}));\n\n\t\t\t\t\t\t\t// ...then short-circuit\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn fetchModule(id, absolutePath).then(function (module) {\n\t\t\t\t\t\t\treturn x.module = module;\n\t\t\t\t\t\t});\n\t\t\t\t\t}, function handleError(err) {\n\t\t\t\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\t\t\t\t// Most likely an external module\n\t\t\t\t\t\t\tvar externalModule = hasOwnProp.call(externalModuleLookup, id) && externalModuleLookup[id];\n\n\t\t\t\t\t\t\tif (!externalModule) {\n\t\t\t\t\t\t\t\texternalModule = {\n\t\t\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\t\t\tisExternal: true\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\texternalModules.push(externalModule);\n\t\t\t\t\t\t\t\texternalModuleLookup[id] = externalModule;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tx.module = externalModule;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}).then(function () {\n\t\t\t\t\treturn modules.push(module);\n\t\t\t\t}).then(function () {\n\t\t\t\t\treturn module;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn promiseByPath[absolutePath];\n\t}\n}\n\nfunction resolvePath(base, userModules, moduleId, importerPath, resolver) {\n\tvar noExt = moduleId.replace(/\\.js$/, '');\n\n\treturn tryPath(base, noExt + '.js', userModules)['catch'](function () {\n\t\treturn tryPath(base, noExt + _path.sep + 'index.js', userModules);\n\t})['catch'](function (err) {\n\t\tvar resolvedPromise = resolver && sander.Promise.resolve(resolver(moduleId, importerPath));\n\n\t\tif (resolvedPromise) {\n\t\t\treturn resolvedPromise.then(function (resolvedPath) {\n\t\t\t\tif (!resolvedPath) {\n\t\t\t\t\t// hack but whatevs, it saves handling real ENOENTs differently\n\t\t\t\t\tvar _err = new Error();\n\t\t\t\t\t_err.code = 'ENOENT';\n\t\t\t\t\tthrow _err;\n\t\t\t\t}\n\n\t\t\t\treturn sander.stat(resolvedPath).then(function () {\n\t\t\t\t\treturn _path.resolve(base, resolvedPath);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t});\n}\n\nfunction tryPath(base, filename, userModules) {\n\tvar absolutePath = _path.resolve(base, filename);\n\n\tif (hasOwnProp.call(userModules, absolutePath)) {\n\t\treturn sander.Promise.resolve(absolutePath);\n\t}\n\treturn sander.stat(absolutePath).then(function () {\n\t\treturn absolutePath;\n\t});\n}\n\nfunction isThenable(obj) {\n\treturn obj && typeof obj.then === 'function';\n}\n\nfunction transformExportDeclaration(declaration, body) {\n\tif (!declaration) {\n\t\treturn;\n\t}\n\n\tvar exportedValue = undefined;\n\n\tswitch (declaration.type) {\n\t\tcase 'namedFunction':\n\t\tcase 'namedClass':\n\t\t\tbody.remove(declaration.start, declaration.valueStart);\n\t\t\texportedValue = declaration.name;\n\t\t\tbreak;\n\n\t\tcase 'anonFunction':\n\t\tcase 'anonClass':\n\t\t\tif (declaration.isFinal) {\n\t\t\t\tbody.replace(declaration.start, declaration.valueStart, 'return ');\n\t\t\t} else {\n\t\t\t\tbody.replace(declaration.start, declaration.valueStart, 'var __export = ');\n\t\t\t\texportedValue = '__export';\n\t\t\t}\n\n\t\t\t// add semi-colon, if necessary\n\t\t\t// TODO body.original is an implementation detail of magic-string - there\n\t\t\t// should probably be an API for this sort of thing\n\t\t\tif (body.original[declaration.end - 1] !== ';') {\n\t\t\t\tbody.insert(declaration.end, ';');\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'expression':\n\t\t\tbody.remove(declaration.start, declaration.next);\n\t\t\texportedValue = declaration.value;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected export type \\'' + declaration.type + '\\'');\n\t}\n\n\tif (exportedValue) {\n\t\tbody.append('\\nreturn ' + exportedValue + ';');\n\t}\n}\n\nvar ABSOLUTE_PATH = /^(?:[A-Z]:)?[\\/\\\\]/i;\n\nvar warned = {};\nfunction packageResult(bundleOrModule, body, options, methodName, isBundle) {\n\t// wrap output\n\tif (options.banner) body.prepend(options.banner);\n\tif (options.footer) body.append(options.footer);\n\n\tvar code = body.toString();\n\tvar map = undefined;\n\n\tif (!!options.sourceMap) {\n\t\tif (options.sourceMap !== 'inline' && !options.sourceMapFile) {\n\t\t\tthrow new Error('You must provide `sourceMapFile` option');\n\t\t}\n\n\t\tif (!isBundle && !options.sourceMapSource) {\n\t\t\tthrow new Error('You must provide `sourceMapSource` option');\n\t\t}\n\n\t\tvar sourceMapFile = undefined;\n\t\tif (options.sourceMap === 'inline') {\n\t\t\tsourceMapFile = null;\n\t\t} else {\n\t\t\tsourceMapFile = ABSOLUTE_PATH.test(options.sourceMapFile) ? options.sourceMapFile : './' + splitPath(options.sourceMapFile).pop();\n\t\t}\n\n\t\tif (isBundle) {\n\t\t\tmarkBundleSourcemapLocations(bundleOrModule);\n\t\t} else {\n\t\t\tmarkModuleSourcemapLocations(bundleOrModule);\n\t\t}\n\n\t\tmap = body.generateMap({\n\t\t\tincludeContent: true,\n\t\t\tfile: sourceMapFile,\n\t\t\tsource: sourceMapFile && !isBundle ? getRelativePath(sourceMapFile, options.sourceMapSource) : null\n\t\t});\n\n\t\tif (options.sourceMap === 'inline') {\n\t\t\tcode += '\\n//# sourceMa' + 'ppingURL=' + map.toUrl();\n\t\t\tmap = null;\n\t\t} else {\n\t\t\tcode += '\\n//# sourceMa' + 'ppingURL=' + sourceMapFile + '.map';\n\t\t}\n\t} else {\n\t\tmap = null;\n\t}\n\n\treturn {\n\t\tcode: code,\n\t\tmap: map,\n\t\ttoString: function () {\n\t\t\tif (!warned[methodName]) {\n\t\t\t\tconsole.log('Warning: esperanto.' + methodName + '() returns an object with a \\'code\\' property. You should use this instead of using the returned value directly');\n\t\t\t\twarned[methodName] = true;\n\t\t\t}\n\n\t\t\treturn code;\n\t\t}\n\t};\n}\n\nfunction getRelativePath(from, to) {\n\tvar fromParts, toParts, i;\n\n\tfromParts = splitPath(from);\n\ttoParts = splitPath(to);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === '.') {\n\t\tfromParts.shift();\n\t}\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\ti = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\n\t\treturn fromParts.concat(toParts).join('/');\n\t} else {\n\t\ttoParts.unshift('.');\n\t\treturn toParts.join('/');\n\t}\n}\n\nfunction markBundleSourcemapLocations(bundle) {\n\tbundle.modules.forEach(function (mod) {\n\t\twalk(mod.ast, {\n\t\t\tenter: function (node) {\n\t\t\t\tmod.body.addSourcemapLocation(node.start);\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction markModuleSourcemapLocations(mod) {\n\twalk(mod.ast, {\n\t\tenter: function (node) {\n\t\t\tmod.body.addSourcemapLocation(node.start);\n\t\t}\n\t});\n}\n\nfunction getImportSummary(_ref) {\n\tvar imports = _ref.imports;\n\tvar absolutePaths = _ref.absolutePaths;\n\tvar name = _ref.name;\n\n\tvar paths = [];\n\tvar names = [];\n\tvar seen = {};\n\tvar placeholders = 0;\n\n\timports.forEach(function (x) {\n\t\tvar path = x.id || x.path; // TODO unify these\n\n\t\tif (!seen[path]) {\n\t\t\tseen[path] = true;\n\n\t\t\tpaths.push(path);\n\n\t\t\t// TODO x could be an external module, or an internal one.\n\t\t\t// they have different shapes, resulting in the confusing\n\t\t\t// code below\n\t\t\tif (x.needsDefault || x.needsNamed || x.specifiers && x.specifiers.length) {\n\t\t\t\twhile (placeholders) {\n\t\t\t\t\tnames.push('__dep' + names.length + '__');\n\t\t\t\t\tplaceholders--;\n\t\t\t\t}\n\t\t\t\tnames.push(x.name);\n\t\t\t} else {\n\t\t\t\tplaceholders++;\n\t\t\t}\n\t\t}\n\t});\n\n\tvar ids = absolutePaths ? paths.map(function (relativePath) {\n\t\treturn resolveId(relativePath, name);\n\t}) : paths.slice();\n\n\treturn { ids: ids, paths: paths, names: names };\n}\n\nfunction processName(name) {\n\treturn name ? quote(name) + ', ' : '';\n}\n\nfunction processIds(ids) {\n\treturn ids.length ? '[' + ids.map(quote).join(', ') + '], ' : '';\n}\n\nfunction amdIntro(_ref) {\n\tvar name = _ref.name;\n\tvar imports = _ref.imports;\n\tvar hasExports = _ref.hasExports;\n\tvar indentStr = _ref.indentStr;\n\tvar absolutePaths = _ref.absolutePaths;\n\tvar useStrict = _ref.useStrict;\n\n\tvar _getImportSummary = getImportSummary({ name: name, imports: imports, absolutePaths: absolutePaths });\n\n\tvar ids = _getImportSummary.ids;\n\tvar names = _getImportSummary.names;\n\n\tif (hasExports) {\n\t\tids.unshift('exports');\n\t\tnames.unshift('exports');\n\t}\n\n\tvar intro = '\\ndefine(' + processName(name) + processIds(ids) + 'function (' + names.join(', ') + ') {\\n\\n';\n\n\tif (useStrict) {\n\t\tintro += indentStr + '\\'use strict\\';\\n\\n';\n\t}\n\n\treturn intro;\n}\n\nvar amd__default = amd__amd;\nfunction amd__amd(mod, options) {\n\tmod.imports.forEach(function (x) {\n\t\tmod.body.remove(x.start, x.next);\n\t});\n\n\ttransformExportDeclaration(mod.exports[0], mod.body);\n\n\tvar intro = amdIntro({\n\t\tname: options.amdName,\n\t\timports: mod.imports,\n\t\tabsolutePaths: options.absolutePaths,\n\t\tindentStr: mod.body.getIndentString(),\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\tmod.body.trim().indent().prepend(intro).trim().append('\\n\\n});');\n\n\treturn packageResult(mod, mod.body, options, 'toAmd');\n}\n\nvar cjs__default = cjs__cjs;\nfunction cjs__cjs(mod, options) {\n\tvar seen = {};\n\n\tmod.imports.forEach(function (x) {\n\t\tif (!hasOwnProp.call(seen, x.path)) {\n\t\t\tvar replacement = x.isEmpty ? req(x.path) + ';' : 'var ' + x.as + ' = ' + req(x.path) + ';';\n\t\t\tmod.body.replace(x.start, x.end, replacement);\n\n\t\t\tseen[x.path] = true;\n\t\t} else {\n\t\t\tmod.body.remove(x.start, x.next);\n\t\t}\n\t});\n\n\tvar exportDeclaration = mod.exports[0];\n\n\tif (exportDeclaration) {\n\t\tswitch (exportDeclaration.type) {\n\t\t\tcase 'namedFunction':\n\t\t\tcase 'namedClass':\n\t\t\t\tmod.body.remove(exportDeclaration.start, exportDeclaration.valueStart);\n\t\t\t\tmod.body.replace(exportDeclaration.end, exportDeclaration.end, '\\nmodule.exports = ' + exportDeclaration.name + ';');\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmod.body.replace(exportDeclaration.start, exportDeclaration.valueStart, 'module.exports = ');\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (options.useStrict !== false) {\n\t\tmod.body.prepend(\"'use strict';\\n\\n\").trimLines();\n\t}\n\n\treturn packageResult(mod, mod.body, options, 'toCjs');\n}\n\nfunction umdIntro(_ref) {\n\tvar amdName = _ref.amdName;\n\tvar name = _ref.name;\n\tvar hasExports = _ref.hasExports;\n\tvar imports = _ref.imports;\n\tvar absolutePaths = _ref.absolutePaths;\n\tvar externalDefaults = _ref.externalDefaults;\n\tvar indentStr = _ref.indentStr;\n\tvar strict = _ref.strict;\n\tvar useStrict = _ref.useStrict;\n\n\tvar useStrictPragma = useStrict ? ' \\'use strict\\';' : '';\n\tvar intro = undefined;\n\n\tif (!hasExports && !imports.length) {\n\t\tintro = '(function (factory) {\\n\\t\\t\\t\\t!(typeof exports === \\'object\\' && typeof module !== \\'undefined\\') &&\\n\\t\\t\\t\\ttypeof define === \\'function\\' && define.amd ? define(' + processName(amdName) + 'factory) :\\n\\t\\t\\t\\tfactory()\\n\\t\\t\\t}(function () {' + useStrictPragma + '\\n\\n\\t\\t\\t';\n\t} else {\n\t\tvar _getImportSummary = getImportSummary({ imports: imports, name: amdName, absolutePaths: absolutePaths });\n\n\t\tvar ids = _getImportSummary.ids;\n\t\tvar paths = _getImportSummary.paths;\n\t\tvar names = _getImportSummary.names;\n\n\t\tvar amdExport = undefined,\n\t\t    cjsExport = undefined,\n\t\t    globalExport = undefined,\n\t\t    defaultsBlock = undefined;\n\n\t\tif (strict) {\n\t\t\tcjsExport = 'factory(' + (hasExports ? ['exports'] : []).concat(paths.map(req)).join(', ') + ')';\n\t\t\tvar globalDeps = (hasExports ? ['(global.' + name + ' = {})'] : []).concat(names.map(globalify)).join(', ');\n\t\t\tglobalExport = 'factory(' + globalDeps + ')';\n\n\t\t\tif (hasExports) {\n\t\t\t\tids.unshift('exports');\n\t\t\t\tnames.unshift('exports');\n\t\t\t}\n\n\t\t\tamdExport = 'define(' + processName(amdName) + processIds(ids) + 'factory)';\n\t\t\tdefaultsBlock = '';\n\t\t\tif (externalDefaults && externalDefaults.length > 0) {\n\t\t\t\tdefaultsBlock = externalDefaults.map(function (x) {\n\t\t\t\t\treturn '\\t' + (x.needsNamed ? 'var ' + x.name + '__default' : x.name) + (' = (\\'default\\' in ' + x.name + ' ? ' + x.name + '[\\'default\\'] : ' + x.name + ');');\n\t\t\t\t}).join('\\n') + '\\n\\n';\n\t\t\t}\n\t\t} else {\n\t\t\tamdExport = 'define(' + processName(amdName) + processIds(ids) + 'factory)';\n\t\t\tcjsExport = (hasExports ? 'module.exports = ' : '') + ('factory(' + paths.map(req).join(', ') + ')');\n\t\t\tglobalExport = (hasExports ? 'global.' + name + ' = ' : '') + ('factory(' + names.map(globalify).join(', ') + ')');\n\n\t\t\tdefaultsBlock = '';\n\t\t}\n\n\t\tintro = '(function (global, factory) {\\n\\t\\t\\t\\ttypeof exports === \\'object\\' && typeof module !== \\'undefined\\' ? ' + cjsExport + ' :\\n\\t\\t\\t\\ttypeof define === \\'function\\' && define.amd ? ' + amdExport + ' :\\n\\t\\t\\t\\t' + globalExport + '\\n\\t\\t\\t}(this, function (' + names.join(', ') + ') {' + useStrictPragma + '\\n\\n\\t\\t\\t' + defaultsBlock;\n\t}\n\n\treturn intro.replace(/^\\t\\t\\t/gm, '').replace(/\\t/g, indentStr);\n}\n\nvar EsperantoError = function (message, data) {\n\tvar prop;\n\n\tthis.message = message;\n\tthis.stack = new Error().stack;\n\n\tfor (prop in data) {\n\t\tif (data.hasOwnProperty(prop)) {\n\t\t\tthis[prop] = data[prop];\n\t\t}\n\t}\n};\n\nEsperantoError.prototype = new Error();\nEsperantoError.prototype.constructor = EsperantoError;\nEsperantoError.prototype.name = 'EsperantoError';\n\nfunction requireName(options) {\n\tif (!options.name) {\n\t\tthrow new EsperantoError('You must supply a `name` option for UMD modules', {\n\t\t\tcode: 'MISSING_NAME'\n\t\t});\n\t}\n}\n\nvar umd__default = umd__umd;\nfunction umd__umd(mod, options) {\n\trequireName(options);\n\n\tmod.imports.forEach(function (x) {\n\t\tmod.body.remove(x.start, x.next);\n\t});\n\n\tvar intro = umdIntro({\n\t\thasExports: mod.exports.length > 0,\n\t\timports: mod.imports,\n\t\tamdName: options.amdName,\n\t\tabsolutePaths: options.absolutePaths,\n\t\tname: options.name,\n\t\tindentStr: mod.body.getIndentString(),\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\ttransformExportDeclaration(mod.exports[0], mod.body);\n\n\tmod.body.indent().prepend(intro).trimLines().append('\\n\\n}));');\n\n\treturn packageResult(mod, mod.body, options, 'toUmd');\n}\n\nvar defaultsMode = {\n\tamd: amd__default,\n\tcjs: cjs__default,\n\tumd: umd__default\n};\n\nfunction gatherImports(imports) {\n\tvar chains = {};\n\tvar identifierReplacements = {};\n\n\timports.forEach(function (x) {\n\t\tx.specifiers.forEach(function (s) {\n\t\t\tif (s.isBatch) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar name = s.as;\n\t\t\tvar replacement = x.name + (s.isDefault ? \"['default']\" : \".\" + s.name);\n\n\t\t\tif (!x.passthrough) {\n\t\t\t\tidentifierReplacements[name] = replacement;\n\t\t\t}\n\n\t\t\tchains[name] = replacement;\n\t\t});\n\t});\n\n\treturn [chains, identifierReplacements];\n}\n\nfunction getExportNames(exports) {\n\tvar result = {};\n\n\texports.forEach(function (x) {\n\t\tif (x.isDefault) return;\n\n\t\tif (x.hasDeclaration) {\n\t\t\tresult[x.name] = x.name;\n\t\t\treturn;\n\t\t}\n\n\t\tx.specifiers.forEach(function (s) {\n\t\t\tresult[s.name] = s.as;\n\t\t});\n\t});\n\n\treturn result;\n}\n\nvar utils_transformBody = utils_transformBody__transformBody;\n\nfunction utils_transformBody__transformBody(mod, body, options) {\n\tvar _gatherImports = gatherImports(mod.imports);\n\n\tvar chains = _gatherImports[0];\n\tvar identifierReplacements = _gatherImports[1];\n\n\tvar exportNames = getExportNames(mod.exports);\n\n\tvar _getReadOnlyIdentifiers = getReadOnlyIdentifiers(mod.imports);\n\n\tvar importedBindings = _getReadOnlyIdentifiers[0];\n\tvar importedNamespaces = _getReadOnlyIdentifiers[1];\n\n\t// ensure no conflict with `exports`\n\tidentifierReplacements.exports = deconflict('exports', mod.ast._declared);\n\n\ttraverseAst(mod.ast, body, identifierReplacements, importedBindings, importedNamespaces, exportNames);\n\n\t// Remove import statements from the body of the module\n\tmod.imports.forEach(function (x) {\n\t\tbody.remove(x.start, x.next);\n\t});\n\n\t// Prepend require() statements (CommonJS output only)\n\tif (options.header) {\n\t\tbody.prepend(options.header + '\\n\\n');\n\t}\n\n\t// Remove export statements (but keep declarations)\n\tmod.exports.forEach(function (x) {\n\t\tif (x.isDefault) {\n\t\t\tif (/^named/.test(x.type)) {\n\t\t\t\t// export default function answer () { return 42; }\n\t\t\t\tbody.remove(x.start, x.valueStart);\n\t\t\t\tbody.insert(x.end, '\\nexports[\\'default\\'] = ' + x.name + ';');\n\t\t\t} else {\n\t\t\t\t// everything else\n\t\t\t\tbody.replace(x.start, x.valueStart, 'exports[\\'default\\'] = ');\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (x.type) {\n\t\t\t\tcase 'varDeclaration': // export var answer = 42; (or let)\n\t\t\t\tcase 'namedFunction': // export function answer () {...}\n\t\t\t\tcase 'namedClass':\n\t\t\t\t\t// export class answer {...}\n\t\t\t\t\tbody.remove(x.start, x.valueStart);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'named':\n\t\t\t\t\t// export { foo, bar };\n\t\t\t\t\tbody.remove(x.start, x.next);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbody.replace(x.start, x.valueStart, 'exports[\\'default\\'] = ');\n\t\t\t}\n\t\t}\n\t});\n\n\t// Append export block (this is the same for all module types, unlike imports)\n\tvar earlyExports = [];\n\tvar lateExports = [];\n\n\tObject.keys(exportNames).forEach(function (name) {\n\t\tvar exportAs = exportNames[name];\n\n\t\tif (chains.hasOwnProperty(name)) {\n\t\t\t// special case - a binding from another module\n\t\t\tif (!options._evilES3SafeReExports) {\n\t\t\t\tearlyExports.push('Object.defineProperty(exports, \\'' + exportAs + '\\', { enumerable: true, get: function () { return ' + chains[name] + '; }});');\n\t\t\t} else {\n\t\t\t\tvar exportSegment = exportAs === 'default' ? \"['default']\" : '.' + exportAs;\n\t\t\t\tlateExports.push('exports' + exportSegment + ' = ' + chains[name] + ';');\n\t\t\t}\n\t\t} else if (~mod.ast._topLevelFunctionNames.indexOf(name)) {\n\t\t\t// functions should be exported early, in\n\t\t\t// case of cyclic dependencies\n\t\t\tearlyExports.push('exports.' + exportAs + ' = ' + name + ';');\n\t\t} else {\n\t\t\tlateExports.push('exports.' + exportAs + ' = ' + name + ';');\n\t\t}\n\t});\n\n\t// Function exports should be exported immediately after 'use strict'\n\tif (earlyExports.length) {\n\t\tbody.trim().prepend(earlyExports.join('\\n') + '\\n\\n');\n\t}\n\n\t// Everything else should be exported at the end\n\tif (lateExports.length) {\n\t\tbody.trim().append('\\n\\n' + lateExports.join('\\n'));\n\t}\n\n\tif (options.intro && options.outro) {\n\t\tbody.indent().prepend(options.intro).trimLines().append(options.outro);\n\t}\n}\n\nfunction deconflict(name, declared) {\n\twhile (hasOwnProp.call(declared, name)) {\n\t\tname = '_' + name;\n\t}\n\n\treturn name;\n}\n\nvar strictMode_amd = strictMode_amd__amd;\nfunction strictMode_amd__amd(mod, options) {\n\tvar intro = amdIntro({\n\t\tname: options.amdName,\n\t\tabsolutePaths: options.absolutePaths,\n\t\timports: mod.imports,\n\t\tindentStr: mod.body.getIndentString(),\n\t\thasExports: mod.exports.length,\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\tutils_transformBody(mod, mod.body, {\n\t\tintro: intro,\n\t\toutro: '\\n\\n});',\n\t\t_evilES3SafeReExports: options._evilES3SafeReExports\n\t});\n\n\treturn packageResult(mod, mod.body, options, 'toAmd');\n}\n\nvar strictMode_cjs = strictMode_cjs__cjs;\nfunction strictMode_cjs__cjs(mod, options) {\n\tvar seen = {};\n\n\t// Create block of require statements\n\tvar importBlock = mod.imports.map(function (x) {\n\t\tif (!hasOwnProp.call(seen, x.path)) {\n\t\t\tseen[x.path] = true;\n\n\t\t\tif (x.isEmpty) {\n\t\t\t\treturn req(x.path) + ';';\n\t\t\t}\n\n\t\t\treturn 'var ' + x.name + ' = ' + req(x.path) + ';';\n\t\t}\n\t}).filter(Boolean).join('\\n');\n\n\tutils_transformBody(mod, mod.body, {\n\t\theader: importBlock,\n\t\t_evilES3SafeReExports: options._evilES3SafeReExports\n\t});\n\n\tif (options.useStrict !== false) {\n\t\tmod.body.prepend(\"'use strict';\\n\\n\").trimLines();\n\t}\n\n\treturn packageResult(mod, mod.body, options, 'toCjs');\n}\n\nvar strictMode_umd = strictMode_umd__umd;\nfunction strictMode_umd__umd(mod, options) {\n\trequireName(options);\n\n\tvar intro = umdIntro({\n\t\thasExports: mod.exports.length > 0,\n\t\timports: mod.imports,\n\t\tamdName: options.amdName,\n\t\tabsolutePaths: options.absolutePaths,\n\t\tname: options.name,\n\t\tindentStr: mod.body.getIndentString(),\n\t\tstrict: true,\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\tutils_transformBody(mod, mod.body, {\n\t\tintro: intro,\n\t\toutro: '\\n\\n}));',\n\t\t_evilES3SafeReExports: options._evilES3SafeReExports\n\t});\n\n\treturn packageResult(mod, mod.body, options, 'toUmd');\n}\n\nvar strictMode = {\n\tamd: strictMode_amd,\n\tcjs: strictMode_cjs,\n\tumd: strictMode_umd\n};\n\n// TODO rewrite with named imports/exports\nvar moduleBuilders = {\n\tdefaultsMode: defaultsMode,\n\tstrictMode: strictMode\n};\n\nvar defaultsMode_amd = defaultsMode_amd__amd;\nfunction defaultsMode_amd__amd(bundle, options) {\n\tvar defaultName = bundle.entryModule.identifierReplacements['default'];\n\tif (defaultName) {\n\t\tbundle.body.append('\\n\\nreturn ' + defaultName + ';');\n\t}\n\n\tvar intro = amdIntro({\n\t\tname: options.amdName,\n\t\timports: bundle.externalModules,\n\t\tindentStr: bundle.body.getIndentString(),\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\tbundle.body.indent().prepend(intro).trimLines().append('\\n\\n});');\n\treturn packageResult(bundle, bundle.body, options, 'toAmd', true);\n}\n\nvar defaultsMode_cjs = defaultsMode_cjs__cjs;\nfunction defaultsMode_cjs__cjs(bundle, options) {\n\tvar importBlock = bundle.externalModules.map(function (x) {\n\t\treturn 'var ' + x.name + ' = ' + req(x.id) + ';';\n\t}).join('\\n');\n\n\tif (importBlock) {\n\t\tbundle.body.prepend(importBlock + '\\n\\n');\n\t}\n\n\tvar defaultName = bundle.entryModule.identifierReplacements['default'];\n\tif (defaultName) {\n\t\tbundle.body.append('\\n\\nmodule.exports = ' + defaultName + ';');\n\t}\n\n\tif (options.useStrict !== false) {\n\t\tbundle.body.prepend(\"'use strict';\\n\\n\").trimLines();\n\t}\n\n\treturn packageResult(bundle, bundle.body, options, 'toCjs', true);\n}\n\nvar defaultsMode_umd = defaultsMode_umd__umd;\nfunction defaultsMode_umd__umd(bundle, options) {\n\trequireName(options);\n\n\tvar entry = bundle.entryModule;\n\n\tvar intro = umdIntro({\n\t\thasExports: entry.exports.length > 0,\n\t\timports: bundle.externalModules,\n\t\tamdName: options.amdName,\n\t\tname: options.name,\n\t\tindentStr: bundle.body.getIndentString(),\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\tif (entry.defaultExport) {\n\t\tbundle.body.append('\\n\\nreturn ' + entry.identifierReplacements['default'] + ';');\n\t}\n\n\tbundle.body.indent().prepend(intro).trimLines().append('\\n\\n}));');\n\n\treturn packageResult(bundle, bundle.body, options, 'toUmd', true);\n}\n\nvar builders_defaultsMode = {\n\tamd: defaultsMode_amd,\n\tcjs: defaultsMode_cjs,\n\tumd: defaultsMode_umd\n};\n\nfunction getExportBlock(entry) {\n\tvar name = entry.identifierReplacements[\"default\"];\n\treturn \"exports['default'] = \" + name + \";\";\n}\n\nvar builders_strictMode_amd = builders_strictMode_amd__amd;\n\nfunction builders_strictMode_amd__amd(bundle, options) {\n\tvar externalDefaults = bundle.externalModules.filter(builders_strictMode_amd__needsDefault);\n\tvar entry = bundle.entryModule;\n\n\tif (externalDefaults.length) {\n\t\tvar defaultsBlock = externalDefaults.map(function (x) {\n\t\t\t// Case 1: default is used, and named is not\n\t\t\tif (!x.needsNamed) {\n\t\t\t\treturn x.name + ' = (\\'default\\' in ' + x.name + ' ? ' + x.name + '[\\'default\\'] : ' + x.name + ');';\n\t\t\t}\n\n\t\t\t// Case 2: both default and named are used\n\t\t\treturn 'var ' + x.name + '__default = (\\'default\\' in ' + x.name + ' ? ' + x.name + '[\\'default\\'] : ' + x.name + ');';\n\t\t}).join('\\n');\n\n\t\tbundle.body.prepend(defaultsBlock + '\\n\\n');\n\t}\n\n\tif (entry.defaultExport) {\n\t\tbundle.body.append('\\n\\n' + getExportBlock(entry));\n\t}\n\n\tvar intro = amdIntro({\n\t\tname: options.amdName,\n\t\timports: bundle.externalModules,\n\t\thasExports: entry.exports.length,\n\t\tindentStr: bundle.body.getIndentString(),\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\tbundle.body.indent().prepend(intro).trimLines().append('\\n\\n});');\n\treturn packageResult(bundle, bundle.body, options, 'toAmd', true);\n}\n\nfunction builders_strictMode_amd__needsDefault(externalModule) {\n\treturn externalModule.needsDefault;\n}\n\nvar builders_strictMode_cjs = builders_strictMode_cjs__cjs;\nfunction builders_strictMode_cjs__cjs(bundle, options) {\n\tvar entry = bundle.entryModule;\n\n\tvar importBlock = bundle.externalModules.map(function (x) {\n\t\tvar statement = 'var ' + x.name + ' = ' + req(x.id) + ';';\n\n\t\tif (x.needsDefault) {\n\t\t\tstatement += '\\n' + (x.needsNamed ? 'var ' + x.name + '__default' : x.name) + (' = (\\'default\\' in ' + x.name + ' ? ' + x.name + '[\\'default\\'] : ' + x.name + ');');\n\t\t}\n\n\t\treturn statement;\n\t}).join('\\n');\n\n\tif (importBlock) {\n\t\tbundle.body.prepend(importBlock + '\\n\\n');\n\t}\n\n\tif (entry.defaultExport) {\n\t\tbundle.body.append('\\n\\n' + getExportBlock(entry));\n\t}\n\n\tif (options.useStrict !== false) {\n\t\tbundle.body.prepend(\"'use strict';\\n\\n\").trimLines();\n\t}\n\n\treturn packageResult(bundle, bundle.body, options, 'toCjs', true);\n}\n\nvar builders_strictMode_umd = builders_strictMode_umd__umd;\n\nfunction builders_strictMode_umd__umd(bundle, options) {\n\trequireName(options);\n\n\tvar entry = bundle.entryModule;\n\n\tvar intro = umdIntro({\n\t\thasExports: entry.exports.length > 0,\n\t\timports: bundle.externalModules,\n\t\texternalDefaults: bundle.externalModules.filter(builders_strictMode_umd__needsDefault),\n\t\tamdName: options.amdName,\n\t\tname: options.name,\n\t\tindentStr: bundle.body.getIndentString(),\n\t\tstrict: true,\n\t\tuseStrict: options.useStrict !== false\n\t});\n\n\tif (entry.defaultExport) {\n\t\tbundle.body.append('\\n\\n' + getExportBlock(entry));\n\t}\n\n\tbundle.body.indent().prepend(intro).trimLines().append('\\n\\n}));');\n\n\treturn packageResult(bundle, bundle.body, options, 'toUmd', true);\n}\n\nfunction builders_strictMode_umd__needsDefault(externalModule) {\n\treturn externalModule.needsDefault;\n}\n\nvar builders_strictMode = {\n\tamd: builders_strictMode_amd,\n\tcjs: builders_strictMode_cjs,\n\tumd: builders_strictMode_umd\n};\n\n// TODO rewrite with named imports/exports\nvar bundleBuilders = {\n\tdefaultsMode: builders_defaultsMode,\n\tstrictMode: builders_strictMode\n};\n\nfunction concat(bundle, options) {\n\t// This bundle must be self-contained - no imports or exports\n\tif (bundle.externalModules.length || bundle.entryModule.exports.length) {\n\t\tthrow new Error('bundle.concat() can only be used with bundles that have no imports/exports (imports: [' + bundle.externalModules.map(function (x) {\n\t\t\treturn x.id;\n\t\t}).join(', ') + '], exports: [' + bundle.entryModule.exports.join(', ') + '])');\n\t}\n\n\t// TODO test these options\n\tvar intro = 'intro' in options ? options.intro : '(function () { \\'use strict\\';\\n\\n';\n\tvar outro = 'outro' in options ? options.outro : '\\n\\n})();';\n\tvar indent = undefined;\n\n\tif (!('indent' in options) || options.indent === true) {\n\t\tindent = bundle.body.getIndentString();\n\t} else {\n\t\tindent = options.indent || '';\n\t}\n\n\tbundle.body.trimLines().indent(indent).prepend(intro).append(outro);\n\n\treturn packageResult(bundle, bundle.body, options, 'toString', true);\n}\n\nvar deprecateMessages = {\n\tdefaultOnly: 'options.defaultOnly has been deprecated, and is now standard behaviour. To use named imports/exports, pass `strict: true`.',\n\tstandalone: chalk.red.bold('[DEPRECATION NOTICE] Esperanto is no longer under active development. To convert an ES6 module to another format, consider using Babel (https://babeljs.io)'),\n\tbundle: chalk.red.bold('[DEPRECATION NOTICE] Esperanto is no longer under active development. To bundle ES6 modules, consider using Rollup (https://github.com/rollup/rollup). See https://github.com/rollup/rollup/wiki/Migrating-from-Esperanto for help migrating')\n};\n\nvar alreadyWarned = {\n\tdefaultOnly: false,\n\tstandalone: false,\n\tbundle: false\n};\n\nfunction transpileMethod(format) {\n\tif (!alreadyWarned.standalone) {\n\t\tconsole.error(deprecateMessages.standalone);\n\t\talreadyWarned.standalone = true;\n\t}\n\n\treturn function (source) {\n\t\tvar options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t\tvar mod = getStandaloneModule({\n\t\t\tsource: source,\n\t\t\tgetModuleName: options.getModuleName,\n\t\t\tstrict: options.strict\n\t\t});\n\n\t\tif ('defaultOnly' in options && !alreadyWarned.defaultOnly) {\n\t\t\t// TODO link to a wiki page explaining this, or something\n\t\t\tconsole.error(deprecateMessages.defaultOnly);\n\t\t\talreadyWarned.defaultOnly = true;\n\t\t}\n\n\t\tif (options.absolutePaths && !options.amdName) {\n\t\t\tthrow new Error('You must specify an `amdName` in order to use the `absolutePaths` option');\n\t\t}\n\n\t\tvar builder = undefined;\n\n\t\tif (!options.strict) {\n\t\t\t// ensure there are no named imports/exports. TODO link to a wiki page...\n\t\t\tif (hasNamedImports(mod) || hasNamedExports(mod)) {\n\t\t\t\tthrow new Error('You must be in strict mode (pass `strict: true`) to use named imports or exports');\n\t\t\t}\n\n\t\t\tbuilder = moduleBuilders.defaultsMode[format];\n\t\t} else {\n\t\t\tbuilder = moduleBuilders.strictMode[format];\n\t\t}\n\n\t\treturn builder(mod, options);\n\t};\n}\n\nvar toAmd = transpileMethod('amd');\nvar toCjs = transpileMethod('cjs');\nvar toUmd = transpileMethod('umd');\n\nfunction bundle(options) {\n\tif (!alreadyWarned.bundle) {\n\t\tconsole.error(deprecateMessages.bundle);\n\t\talreadyWarned.bundle = true;\n\t}\n\n\treturn getBundle(options).then(function (bundle) {\n\t\treturn {\n\t\t\timports: bundle.externalModules.map(function (mod) {\n\t\t\t\treturn mod.id;\n\t\t\t}),\n\t\t\texports: flattenExports(bundle.entryModule.exports),\n\n\t\t\ttoAmd: function (options) {\n\t\t\t\treturn transpile('amd', options);\n\t\t\t},\n\t\t\ttoCjs: function (options) {\n\t\t\t\treturn transpile('cjs', options);\n\t\t\t},\n\t\t\ttoUmd: function (options) {\n\t\t\t\treturn transpile('umd', options);\n\t\t\t},\n\n\t\t\tconcat: function (options) {\n\t\t\t\treturn concat(bundle, options || {});\n\t\t\t}\n\t\t};\n\n\t\tfunction transpile(format) {\n\t\t\tvar options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t\t\tif ('defaultOnly' in options && !alreadyWarned.defaultOnly) {\n\t\t\t\t// TODO link to a wiki page explaining this, or something\n\t\t\t\tconsole.error(deprecateMessages.defaultOnly);\n\t\t\t\talreadyWarned.defaultOnly = true;\n\t\t\t}\n\n\t\t\tvar builder = undefined;\n\n\t\t\tif (!options.strict) {\n\t\t\t\t// ensure there are no named imports/exports\n\t\t\t\tif (hasNamedExports(bundle.entryModule)) {\n\t\t\t\t\tthrow new Error('Entry module can only have named exports in strict mode (pass `strict: true`)');\n\t\t\t\t}\n\n\t\t\t\tbundle.modules.forEach(function (mod) {\n\t\t\t\t\tmod.imports.forEach(function (x) {\n\t\t\t\t\t\tif (x.module.isExternal && !x.isDefault && !x.isBatch) {\n\t\t\t\t\t\t\tthrow new Error('You can only have named external imports in strict mode (pass `strict: true`)');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tbuilder = bundleBuilders.defaultsMode[format];\n\t\t\t} else {\n\t\t\t\tbuilder = bundleBuilders.strictMode[format];\n\t\t\t}\n\n\t\t\treturn builder(bundle, options);\n\t\t}\n\t});\n}\n\nfunction flattenExports(exports) {\n\tvar flattened = [];\n\n\texports.forEach(function (x) {\n\t\tif (x.isDefault) {\n\t\t\tflattened.push('default');\n\t\t} else if (x.name) {\n\t\t\tflattened.push(x.name);\n\t\t} else if (x.specifiers) {\n\t\t\tflattened.push.apply(flattened, x.specifiers.map(function (x) {\n\t\t\t\treturn x.as;\n\t\t\t}));\n\t\t}\n\t});\n\n\treturn flattened;\n}\n\nexports.bundle = bundle;\nexports.toAmd = toAmd;\nexports.toCjs = toCjs;\nexports.toUmd = toUmd;\n//# sourceMappingURL=/www/ESPERANTO/esperanto/.gobble-build/02-esperantoBundle/1/esperanto.js.map","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/bin/handleError.js":"var chalk = require( 'chalk' );\n\nvar handlers = {\n\tMISSING_INPUT_OPTION: function () {\n\t\tconsole.error( chalk.red( 'You must specify an --input (-i) option when bundling' ) );\n\t},\n\n\tMISSING_OUTPUT_OPTION: function () {\n\t\tconsole.error( chalk.red( 'You must specify an --output (-o) directory option when converting a directory of files' ) );\n\t},\n\n\tNO_INPUT_DETECTED: function () {\n\t\tconsole.error( chalk.red( 'No input detected! Try using the --input (-i) option' ) );\n\t},\n\n\tMISSING_NAME: function ( err ) {\n\t\tconsole.error( chalk.red( 'You must supply a name for UMD exports (e.g. `--name myModule`)' ) );\n\t}\n};\n\nmodule.exports = function handleError ( err ) {\n\tvar handler;\n\n\tif ( handler = handlers[ err && err.code ] ) {\n\t\thandler( err );\n\t} else {\n\t\tconsole.error( chalk.red( err.message || err ) );\n\n\t\tif ( err.stack ) {\n\t\t\tconsole.error( chalk.grey( err.stack ) );\n\t\t}\n\t}\n\n\tconsole.error( 'Type ' + chalk.cyan( 'esperanto --help' ) + ' for help, or visit https://github.com/esperantojs/esperanto/wiki' );\n\n\tprocess.exit( 1 );\n};\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/bin/runEsperanto.js":"var path = require( 'path' ),\n\tsander = require( 'sander' ),\n\tPromise = sander.Promise,\n\thandleError = require( './handleError' ),\n\tesperanto = require( '../' );\n\nvar methods = {\n\tamd: 'toAmd',\n\tcjs: 'toCjs',\n\tumd: 'toUmd'\n};\n\nmodule.exports = function ( options ) {\n\tvar method;\n\n\tif ( options.type && !methods[ options.type ] ) {\n\t\tconsole.error( 'The --type (-t) option must be one of amd, cjs, umd' );\n\t\tprocess.exit( 1 );\n\t}\n\n\tmethod = methods[ options.type ] || 'toAmd';\n\n\ttry {\n\t\tif ( options.bundle ) {\n\t\t\tbundle( options, method ).catch( handleError );\n\t\t} else {\n\t\t\tconvert( options, method ).catch( handleError );\n\t\t}\n\t} catch ( err ) {\n\t\thandleError( err );\n\t}\n};\n\nfunction bundle ( options, method ) {\n\tvar bundleOptions, file;\n\n\tif ( !options.input ) {\n\t\thandleError({ code: 'MISSING_INPUT_OPTION' });\n\t}\n\n\tbundleOptions = {\n\t\tbase: path.resolve( options.basedir || '' )\n\t};\n\n\tif ( options.skip ) {\n\t\tbundleOptions.skip = options.skip.split( ',' ).map( function ( file ) {\n\t\t\treturn file.replace( /\\.js$/, '' );\n\t\t});\n\t}\n\n\t// entry should be relative to base\n\tif ( options.basedir && !sander.existsSync( path.join( bundleOptions.base, options.input ) ) ) {\n\t\t// file doesn't exist relative to base...\n\t\tfile = path.resolve( options.input ).replace( bundleOptions.base + '/', '' );\n\t} else {\n\t\tfile = path.resolve( bundleOptions.base, options.input );\n\t}\n\n\tbundleOptions.entry = file;\n\n\treturn esperanto.bundle( bundleOptions ).then( function ( bundle ) {\n\t\tvar transpiled, promises;\n\n\t\ttranspiled = bundle[ method ]({\n\t\t\tname: options.name,\n\t\t\tamdName: options.amdName,\n\t\t\tstrict: options.strict,\n\t\t\tsourceMap: options.sourcemap,\n\t\t\tsourceMapFile: options.sourcemap ? path.resolve( options.output ) : null\n\t\t});\n\n\t\tif ( options.output ) {\n\t\t\tpromises = [ sander.writeFile( options.output, transpiled.code ) ];\n\n\t\t\tif ( options.sourcemap === true ) {\n\t\t\t\tpromises.push( sander.writeFile( options.output + '.map', transpiled.map ) );\n\t\t\t}\n\n\t\t\treturn Promise.all( promises );\n\t\t} else {\n\t\t\tprocess.stdout.write( transpiled.code );\n\t\t}\n\t});\n}\n\nfunction convert ( options, method ) {\n\tif ( options.input ) {\n\t\treturn sander.stat( options.input ).then( function ( stats ) {\n\t\t\tif ( stats.isDirectory() ) {\n\t\t\t\tif ( !options.output ) {\n\t\t\t\t\thandleError({ code: 'MISSING_OUTPUT_OPTION' });\n\t\t\t\t}\n\n\t\t\t\t// transpile all the things\n\t\t\t\treturn sander.lsr( options.input )\n\t\t\t\t\t.then( filterOutNonJs )\n\t\t\t\t\t.then( function ( files ) {\n\t\t\t\t\t\tvar promises = files.map( function ( file ) {\n\t\t\t\t\t\t\tvar input = path.join( options.input, file );\n\t\t\t\t\t\t\tvar output = path.join( options.output, file );\n\n\t\t\t\t\t\t\tvar fileOptions = assign( {}, options, {\n\t\t\t\t\t\t\t\tinput: input,\n\t\t\t\t\t\t\t\toutput: output,\n\t\t\t\t\t\t\t\tsourceMapSource: input,\n\t\t\t\t\t\t\t\tsourceMapFile: output\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn convert( fileOptions, method );\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn Promise.all( promises );\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn sander.readFile( options.input )\n\t\t\t\t.then( String )\n\t\t\t\t.then( run );\n\t\t});\n\t} else {\n\t\treturn readFromStdin().then( run );\n\t}\n\n\tfunction run ( source ) {\n\t\tvar transpiled, promises;\n\n\t\ttranspiled = esperanto[ method ]( source, {\n\t\t\tstrict: options.strict,\n\t\t\tname: options.name,\n\t\t\tamdName: options.amdName,\n\t\t\tsourceMap: options.sourcemap,\n\t\t\tsourceMapSource: options.input,\n\t\t\tsourceMapFile: options.output\n\t\t});\n\n\t\tif ( options.output ) {\n\t\t\tpromises = [ sander.writeFile( options.output, transpiled.code ) ];\n\n\t\t\tif ( options.sourcemap === true ) {\n\t\t\t\tpromises.push( sander.writeFile( options.output + '.map', transpiled.map ) );\n\t\t\t}\n\n\t\t\treturn Promise.all( promises );\n\t\t}\n\n\t\tprocess.stdout.write( transpiled.code );\n\t}\n}\n\nfunction readFromStdin () {\n\treturn new Promise( function ( fulfil, reject ) {\n\t\tvar data = '';\n\n\t\tif ( process.stdin.isTTY ) {\n\t\t\thandleError({ code: 'NO_INPUT_DETECTED' });\n\t\t}\n\n\t\tprocess.stdin.setEncoding( 'utf8' );\n\n\t\tprocess.stdin.on( 'readable', function () {\n\t\t\tvar chunk = process.stdin.read();\n\t\t\tif ( chunk !== null ) {\n\t\t\t\tdata += chunk;\n\t\t\t}\n\t\t});\n\n\t\tprocess.stdin.on( 'end', function() {\n\t\t\tfulfil( data );\n\t\t});\n\n\t\tprocess.stdin.on( 'error', reject );\n\t});\n}\n\nfunction assign ( target ) {\n\tvar sources = [].slice.call( arguments, 1 );\n\n\tsources.forEach( function ( source ) {\n\t\tvar prop;\n\n\t\tfor ( prop in source ) {\n\t\t\tif ( source.hasOwnProperty( prop ) ) {\n\t\t\t\ttarget[ prop ] = source[ prop ];\n\t\t\t}\n\t\t}\n\t});\n\n\treturn target;\n}\n\nfunction filterOutNonJs ( files ) {\n\tvar isJs = /\\.js$/;\n\treturn files.filter( function ( file ) {\n\t\treturn isJs.test( file );\n\t});\n}","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/bin/showHelp.js":"var fs = require( 'fs' ),\n\tpath = require( 'path' );\n\nmodule.exports = function () {\n\tfs.readFile( path.join( __dirname, 'help.md' ), function ( err, result ) {\n\t\tvar help;\n\n\t\tif ( err ) throw err;\n\n\t\thelp = result.toString().replace( '<%= version %>', require( '../package.json' ).version );\n\t\tconsole.log( '\\n' + help + '\\n' );\n\t});\n};","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/banner.js":"/*\n\tesperanto.js v${VERSION} - ${TODAY}\n\thttp://esperantojs.org\n\n\tReleased under the MIT License.\n*/\n\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/esperanto.js":"import chalk from 'chalk';\nimport hasNamedImports from 'utils/hasNamedImports';\nimport hasNamedExports from 'utils/hasNamedExports';\nimport getStandaloneModule from 'standalone/getModule';\nimport getBundle from 'bundler/getBundle';\nimport moduleBuilders from 'standalone/builders';\nimport bundleBuilders from 'bundler/builders';\nimport concat from 'bundler/builders/concat';\nimport { getName } from 'utils/mappers';\n\nlet deprecateMessages = {\n\tdefaultOnly: 'options.defaultOnly has been deprecated, and is now standard behaviour. To use named imports/exports, pass `strict: true`.',\n\tstandalone: chalk.red.bold( '[DEPRECATION NOTICE] Esperanto is no longer under active development. To convert an ES6 module to another format, consider using Babel (https://babeljs.io)' ),\n\tbundle: chalk.red.bold( '[DEPRECATION NOTICE] Esperanto is no longer under active development. To bundle ES6 modules, consider using Rollup (https://github.com/rollup/rollup). See https://github.com/rollup/rollup/wiki/Migrating-from-Esperanto for help migrating' )\n};\n\nlet alreadyWarned = {\n\tdefaultOnly: false,\n\tstandalone: false,\n\tbundle: false\n};\n\nfunction transpileMethod ( format ) {\n\tif ( !alreadyWarned.standalone ) {\n\t\tconsole.error( deprecateMessages.standalone );\n\t\talreadyWarned.standalone = true;\n\t}\n\n\treturn function ( source, options = {} ) {\n\t\tlet mod = getStandaloneModule({\n\t\t\tsource,\n\t\t\tgetModuleName: options.getModuleName,\n\t\t\tstrict: options.strict\n\t\t});\n\n\t\tif ( 'defaultOnly' in options && !alreadyWarned.defaultOnly ) {\n\t\t\t// TODO link to a wiki page explaining this, or something\n\t\t\tconsole.error( deprecateMessages.defaultOnly );\n\t\t\talreadyWarned.defaultOnly = true;\n\t\t}\n\n\t\tif ( options.absolutePaths && !options.amdName ) {\n\t\t\tthrow new Error( 'You must specify an `amdName` in order to use the `absolutePaths` option' );\n\t\t}\n\n\t\tlet builder;\n\n\t\tif ( !options.strict ) {\n\t\t\t// ensure there are no named imports/exports. TODO link to a wiki page...\n\t\t\tif ( hasNamedImports( mod ) || hasNamedExports( mod ) ) {\n\t\t\t\tthrow new Error( 'You must be in strict mode (pass `strict: true`) to use named imports or exports' );\n\t\t\t}\n\n\t\t\tbuilder = moduleBuilders.defaultsMode[ format ];\n\t\t} else {\n\t\t\tbuilder = moduleBuilders.strictMode[ format ];\n\t\t}\n\n\t\treturn builder( mod, options );\n\t};\n}\n\nexport const toAmd = transpileMethod( 'amd' );\nexport const toCjs = transpileMethod( 'cjs' );\nexport const toUmd = transpileMethod( 'umd' );\n\nexport function bundle ( options ) {\n\tif ( !alreadyWarned.bundle ) {\n\t\tconsole.error( deprecateMessages.bundle );\n\t\talreadyWarned.bundle = true;\n\t}\n\n\treturn getBundle( options ).then( function ( bundle ) {\n\t\treturn {\n\t\t\timports: bundle.externalModules.map( mod => mod.id ),\n\t\t\texports: flattenExports( bundle.entryModule.exports ),\n\n\t\t\ttoAmd: options => transpile( 'amd', options ),\n\t\t\ttoCjs: options => transpile( 'cjs', options ),\n\t\t\ttoUmd: options => transpile( 'umd', options ),\n\n\t\t\tconcat: options => concat( bundle, options || {} )\n\t\t};\n\n\t\tfunction transpile ( format, options = {} ) {\n\t\t\tif ( 'defaultOnly' in options && !alreadyWarned.defaultOnly ) {\n\t\t\t\t// TODO link to a wiki page explaining this, or something\n\t\t\t\tconsole.error( deprecateMessages.defaultOnly );\n\t\t\t\talreadyWarned.defaultOnly = true;\n\t\t\t}\n\n\t\t\tlet builder;\n\n\t\t\tif ( !options.strict ) {\n\t\t\t\t// ensure there are no named imports/exports\n\t\t\t\tif ( hasNamedExports( bundle.entryModule ) ) {\n\t\t\t\t\tthrow new Error( 'Entry module can only have named exports in strict mode (pass `strict: true`)' );\n\t\t\t\t}\n\n\t\t\t\tbundle.modules.forEach( mod => {\n\t\t\t\t\tmod.imports.forEach( x => {\n\t\t\t\t\t\tif ( x.module.isExternal && ( !x.isDefault && !x.isBatch ) ) {\n\t\t\t\t\t\t\tthrow new Error( 'You can only have named external imports in strict mode (pass `strict: true`)' );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tbuilder = bundleBuilders.defaultsMode[ format ];\n\t\t\t} else {\n\t\t\t\tbuilder = bundleBuilders.strictMode[ format ];\n\t\t\t}\n\n\t\t\treturn builder( bundle, options );\n\t\t}\n\t});\n}\n\nfunction flattenExports ( exports ) {\n\tlet flattened = [];\n\n\texports.forEach( x => {\n\t\tif ( x.isDefault ) {\n\t\t\tflattened.push( 'default' );\n\t\t}\n\n\t\telse if ( x.name ) {\n\t\t\tflattened.push( x.name );\n\t\t}\n\n\t\telse if ( x.specifiers ) {\n\t\t\tflattened.push.apply( flattened, x.specifiers.map( x => x.as ) );\n\t\t}\n\t});\n\n\treturn flattened;\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/bundler/getBundle.js":"import { relative, resolve, sep } from 'path';\nimport hasOwnProp from 'utils/hasOwnProp';\nimport resolveId from 'utils/resolveId';\nimport promiseSequence from 'utils/promiseSequence';\nimport sortModules from './utils/sortModules';\nimport resolveChains from './utils/resolveChains';\nimport combine from './combine';\nimport { readFile, stat, Promise } from 'sander';\nimport getModule from './getModule';\n\nexport default function getBundle ( options ) {\n\tlet entry = options.entry.replace( /\\.js$/, '' );\n\tlet userModules = options.modules || {};\n\tlet modules = [];\n\tlet moduleLookup = {};\n\tlet promiseByPath = {};\n\tlet skip = options.skip;\n\tlet names = options.names;\n\tlet base = ( options.base ? resolve( options.base ) : process.cwd() ) + '/';\n\tlet externalModules = [];\n\tlet externalModuleLookup = {};\n\n\tif ( !entry.indexOf( base ) ) {\n\t\tentry = entry.substring( base.length );\n\t}\n\n\t// resolve user module paths\n\toptions.modules && Object.keys( options.modules ).forEach( relativePath => {\n\t\tuserModules[ resolve( base, relativePath ) ] = options.modules[ relativePath ];\n\t});\n\n\tlet cyclicalModules = [];\n\n\treturn resolvePath( base, userModules, entry, null ).then( absolutePath => {\n\t\treturn fetchModule( entry, absolutePath ).then( entryModule => {\n\t\t\treturn Promise.all( cyclicalModules ).then( () => {\n\t\t\t\t// if the bundle contains cyclical modules,\n\t\t\t\t// we may need to sort it again\n\t\t\t\tif ( cyclicalModules.length ) {\n\t\t\t\t\tmodules = sortModules( entryModule );\n\t\t\t\t}\n\n\t\t\t\tlet bundle = {\n\t\t\t\t\tentryModule,\n\t\t\t\t\tmodules,\n\t\t\t\t\texternalModules,\n\t\t\t\t\tnames\n\t\t\t\t};\n\n\t\t\t\tresolveChains( modules, moduleLookup );\n\t\t\t\tcombine( bundle );\n\n\t\t\t\treturn bundle;\n\t\t\t});\n\n\t\t});\n\t}, function ( err ) {\n\t\tif ( err.code === 'ENOENT' ) {\n\t\t\tthrow new Error( 'Could not find entry module (' + entry + ')' );\n\t\t}\n\n\t\tthrow err;\n\t});\n\n\tfunction fetchModule ( moduleId, absolutePath ) {\n\t\tif ( !hasOwnProp.call( promiseByPath, absolutePath ) ) {\n\t\t\tpromiseByPath[ absolutePath ] = (\n\t\t\t\thasOwnProp.call( userModules, absolutePath ) ?\n\t\t\t\t\tPromise.resolve( userModules[ absolutePath ] ) :\n\t\t\t\t\treadFile( absolutePath ).then( String )\n\t\t\t).then( function ( source ) {\n\t\t\t\tlet code, ast;\n\n\t\t\t\t// normalise\n\t\t\t\tif ( typeof source === 'object' ) {\n\t\t\t\t\tcode = source.code;\n\t\t\t\t\tast = source.ast;\n\t\t\t\t} else {\n\t\t\t\t\tcode = source;\n\t\t\t\t\tast = null;\n\t\t\t\t}\n\n\t\t\t\tif ( options.transform ) {\n\t\t\t\t\tcode = options.transform( code, absolutePath );\n\n\t\t\t\t\tif ( typeof code !== 'string' && !isThenable( code ) ) {\n\t\t\t\t\t\tthrow new Error( 'transform should return String or Promise' );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet module = getModule({\n\t\t\t\t\tid: moduleId,\n\t\t\t\t\tpath: absolutePath,\n\t\t\t\t\tcode,\n\t\t\t\t\tast\n\t\t\t\t});\n\n\t\t\t\tmoduleLookup[ moduleId ] = module;\n\n\t\t\t\treturn promiseSequence( module.imports, x => {\n\t\t\t\t\tconst id = resolveId( x.path, module.path ).replace( base.replace(/\\\\/g, '/'), '' );\n\n\t\t\t\t\tif ( id === moduleId ) {\n\t\t\t\t\t\tthrow new Error( `A module (${moduleId}) cannot import itself` );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some modules can be skipped\n\t\t\t\t\tif ( skip && ~skip.indexOf( id ) ) {\n\t\t\t\t\t\tconst skippedModule = {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tisSkipped: true\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tx.module = skippedModule;\n\t\t\t\t\t\treturn skippedModule;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolvePath( base, userModules, id, absolutePath, options.resolvePath ).then( absolutePath => {\n\t\t\t\t\t\tlet promise = hasOwnProp.call( promiseByPath, absolutePath ) && promiseByPath[ absolutePath ];\n\t\t\t\t\t\tlet cyclical = !!promise;\n\n\t\t\t\t\t\tif ( cyclical ) {\n\t\t\t\t\t\t\t// ensure all modules are set before we\n\t\t\t\t\t\t\t// create the bundle...\n\t\t\t\t\t\t\tcyclicalModules.push(\n\t\t\t\t\t\t\t\tpromise.then( module => x.module = module )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// ...then short-circuit\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn fetchModule( id, absolutePath ).then( module => x.module = module );\n\t\t\t\t\t}, function handleError ( err ) {\n\t\t\t\t\t\tif ( err.code === 'ENOENT' ) {\n\t\t\t\t\t\t\t// Most likely an external module\n\t\t\t\t\t\t\tlet externalModule = hasOwnProp.call( externalModuleLookup, id ) && externalModuleLookup[ id ];\n\n\t\t\t\t\t\t\tif ( !externalModule ) {\n\t\t\t\t\t\t\t\texternalModule = {\n\t\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\t\tisExternal: true\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\texternalModules.push( externalModule );\n\t\t\t\t\t\t\t\texternalModuleLookup[ id ] = externalModule;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tx.module = externalModule;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t})\n\t\t\t\t.then( () => modules.push( module ) )\n\t\t\t\t.then( () => module );\n\t\t\t});\n\t\t}\n\n\t\treturn promiseByPath[ absolutePath ];\n\t}\n}\n\nfunction resolvePath ( base, userModules, moduleId, importerPath, resolver ) {\n\tconst noExt = moduleId.replace( /\\.js$/, '' );\n\n\treturn tryPath( base, noExt + '.js', userModules )\n\t\t.catch( () => tryPath( base, noExt + sep + 'index.js', userModules ) )\n\t\t.catch( function ( err ) {\n\t\t\tconst resolvedPromise = resolver && Promise.resolve( resolver( moduleId, importerPath ) );\n\n\t\t\tif ( resolvedPromise ) {\n\t\t\t\treturn resolvedPromise.then( resolvedPath => {\n\t\t\t\t\tif ( !resolvedPath ) {\n\t\t\t\t\t\t// hack but whatevs, it saves handling real ENOENTs differently\n\t\t\t\t\t\tlet err = new Error();\n\t\t\t\t\t\terr.code = 'ENOENT';\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn stat( resolvedPath ).then( () => resolve( base, resolvedPath ) );\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t});\n}\n\nfunction tryPath ( base, filename, userModules ) {\n\tconst absolutePath = resolve( base, filename );\n\n\tif ( hasOwnProp.call( userModules, absolutePath ) ) {\n\t\treturn Promise.resolve( absolutePath );\n\t}\n\treturn stat( absolutePath ).then( () => absolutePath );\n}\n\nfunction isThenable ( obj ) {\n\treturn obj && typeof obj.then === 'function';\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/bundler/getModule.js":"import { parse } from 'acorn';\nimport MagicString from 'magic-string';\nimport findImportsAndExports from 'utils/ast/findImportsAndExports';\nimport annotateAst from 'utils/ast/annotate';\nimport disallowConflictingImports from '../utils/disallowConflictingImports';\n\nexport default function getModule ( mod ) {\n\tmod.body = new MagicString( mod.code );\n\n\tlet toRemove = [];\n\tlet comments = [];\n\n\ttry {\n\t\tmod.ast = mod.ast || ( parse( mod.code, {\n\t\t\tecmaVersion: 6,\n\t\t\tsourceType: 'module',\n\t\t\tonComment ( block, text, start, end ) {\n\t\t\t\t// sourceMappingURL comments should be removed\n\t\t\t\tif ( !block && /^# sourceMappingURL=/.test( text ) ) {\n\t\t\t\t\ttoRemove.push({ start, end });\n\t\t\t\t} else {\n\t\t\t\t\tcomments.push({ start, end });\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t} catch ( err ) {\n\t\t// If there's a parse error, attach file info\n\t\t// before throwing the error\n\t\tif ( err.loc ) {\n\t\t\terr.file = mod.path;\n\t\t}\n\n\t\tthrow err;\n\t}\n\n\t// remove sourceMappingURL comments\n\ttoRemove.forEach( ({ start, end }) => mod.body.remove( start, end ) );\n\n\tlet { imports, exports, defaultExport } = findImportsAndExports( mod.ast, mod.code, comments );\n\n\tdisallowConflictingImports( imports );\n\n\tmod.imports = imports;\n\tmod.exports = exports;\n\tmod.defaultExport = defaultExport;\n\n\tconst defaultExportIdentifier = defaultExport &&\n\t                                defaultExport.type === 'expression' &&\n\t                                defaultExport.node.declaration &&\n\t                                defaultExport.node.declaration.type === 'Identifier' &&\n\t                                defaultExport.node.declaration;\n\n\t// if the default export is an expression like `export default foo`, we\n\t// can *probably* just use `foo` to refer to said export throughout the\n\t// bundle. Tracking assignments to `foo` allows us to be sure that that's\n\t// the case (i.e. that the module doesn't assign a different value to foo\n\t// after it's been exported)\n\tannotateAst( mod.ast, {\n\t\ttrackAssignments: defaultExportIdentifier\n\t});\n\n\tif ( defaultExportIdentifier && defaultExportIdentifier._assignments ) {\n\t\tlet i = defaultExportIdentifier._assignments.length;\n\t\twhile ( i-- ) {\n\t\t\tconst assignment = defaultExportIdentifier._assignments[i];\n\n\t\t\t// if either a) the assignment happens inside a function body, or\n\t\t\t// b) it happens after the `export default ...`, then it's unsafe to\n\t\t\t// use the identifier, and we need to essentially do `var _foo = foo`\n\t\t\tif ( assignment.scope.parent || assignment.node.start > defaultExport.start ) {\n\t\t\t\tdefaultExport.unsafe = true; // TODO better property name than 'unsafe'\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// identifiers to replace within this module\n\t// (gets filled in later, once bundle is combined)\n\tmod.identifierReplacements = {};\n\n\t// collect exports by name, for quick lookup when verifying\n\t// that this module exports a given identifier\n\tmod.doesExport = {};\n\n\texports.forEach( x => {\n\t\tif ( x.isDefault ) {\n\t\t\tmod.doesExport.default = true;\n\t\t}\n\n\t\telse if ( x.name ) {\n\t\t\tmod.doesExport[ x.name ] = true;\n\t\t}\n\n\t\telse if ( x.specifiers ) {\n\t\t\tx.specifiers.forEach( s => {\n\t\t\t\tmod.doesExport[ s.as ] = true;\n\t\t\t});\n\t\t}\n\n\t\telse {\n\t\t\tthrow new Error( 'Unexpected export type' );\n\t\t}\n\t});\n\n\treturn mod;\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/standalone/getModule.js":"import { parse } from 'acorn';\nimport MagicString from 'magic-string';\nimport annotateAst from 'utils/ast/annotate';\nimport findImportsAndExports from 'utils/ast/findImportsAndExports';\nimport getUnscopedNames from 'utils/ast/getUnscopedNames';\nimport disallowConflictingImports from '../utils/disallowConflictingImports';\nimport hasOwnProp from 'utils/hasOwnProp';\nimport { default as sanitize, splitPath } from 'utils/sanitize';\n\nconst SOURCEMAPPINGURL_REGEX = /^# sourceMappingURL=/;\n\nexport default function getStandaloneModule ( options ) {\n\tlet code, ast;\n\n\tif ( typeof options.source === 'object' ) {\n\t\tcode = options.source.code;\n\t\tast = options.source.ast;\n\t} else {\n\t\tcode = options.source;\n\t}\n\n\tlet toRemove = [];\n\tlet comments = [];\n\n\tlet mod = {\n\t\tbody: new MagicString( code ),\n\t\tast: ast || ( parse( code, {\n\t\t\tecmaVersion: 6,\n\t\t\tsourceType: 'module',\n\t\t\tonComment ( block, text, start, end ) {\n\t\t\t\t// sourceMappingURL comments should be removed\n\t\t\t\tif ( !block && SOURCEMAPPINGURL_REGEX.test( text ) ) {\n\t\t\t\t\ttoRemove.push({ start, end });\n\t\t\t\t} else {\n\t\t\t\t\tcomments.push({ start, end });\n\t\t\t\t}\n\t\t\t}\n\t\t}))\n\t};\n\n\ttoRemove.forEach( ({ start, end }) => mod.body.remove( start, end ) );\n\n\tlet { imports, exports, defaultExport } = findImportsAndExports( mod.ast, code, comments );\n\n\tdisallowConflictingImports( imports );\n\n\tmod.imports = imports;\n\tmod.exports = exports;\n\tmod.defaultExport = defaultExport;\n\n\tlet conflicts = {};\n\n\tif ( options.strict ) {\n\t\tannotateAst( mod.ast, {\n\t\t\ttrackAssignments: null\n\t\t});\n\n\t\t// TODO there's probably an easier way to get this array\n\t\tObject.keys( mod.ast._declared ).concat( getUnscopedNames( mod ) ).forEach( n => {\n\t\t\tconflicts[n] = true;\n\t\t});\n\t}\n\n\tdetermineImportNames( imports, options.getModuleName, conflicts );\n\n\treturn mod;\n}\n\nfunction determineImportNames ( imports, userFn, usedNames ) {\n\tlet nameById = {};\n\tlet inferredNames = {};\n\n\timports.forEach( x => {\n\t\tlet moduleId = x.path;\n\t\tlet name;\n\n\t\tmoduleId = x.path;\n\n\t\t// use existing value\n\t\tif ( hasOwnProp.call( nameById, moduleId ) ) {\n\t\t\tx.name = nameById[ moduleId ];\n\t\t\treturn;\n\t\t}\n\n\t\t// if user supplied a function, defer to it\n\t\tif ( userFn && ( name = userFn( moduleId ) ) ) {\n\t\t\tname = sanitize( name );\n\n\t\t\tif ( hasOwnProp.call( usedNames, name ) ) {\n\t\t\t\t// TODO write a test for this\n\t\t\t\tthrow new Error( `Naming collision: module ${moduleId} cannot be called ${name}` );\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tlet parts = splitPath( moduleId );\n\t\t\tlet i;\n\t\t\tlet prefix = '';\n\t\t\tlet candidate;\n\n\t\t\tdo {\n\t\t\t\ti = parts.length;\n\t\t\t\twhile ( i-- > 0 ) {\n\t\t\t\t\tcandidate = prefix + sanitize( parts.slice( i ).join( '__' ) );\n\n\t\t\t\t\tif ( !hasOwnProp.call( usedNames, candidate ) ) {\n\t\t\t\t\t\tname = candidate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix += '_';\n\t\t\t} while ( !name );\n\t\t}\n\n\t\tusedNames[ name ] = true;\n\t\tnameById[ moduleId ] = name;\n\n\t\tx.name = name;\n\t});\n\n\t// use inferred names for default imports, wherever they\n\t// don't clash with path-based names\n\timports.forEach( x => {\n\t\tif ( x.as && !hasOwnProp.call( usedNames, x.as ) ) {\n\t\t\tinferredNames[ x.path ] = x.as;\n\t\t}\n\t});\n\n\timports.forEach( x => {\n\t\tif ( hasOwnProp.call( inferredNames, x.path ) ) {\n\t\t\tx.name = inferredNames[ x.path ];\n\t\t}\n\t});\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/builtins.js":"// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n// we add `exports` to this list, to avoid conflicts\nexport default 'Array ArrayBuffer DataView Date Error EvalError Float32Array Float64Array Function Generator GeneratorFunction Infinity Int16Array Int32Array Int8Array InternalError Intl Iterator JSON Map Math NaN Number Object ParallelArray Promise Proxy RangeError ReferenceError Reflect RegExp Set StopIteration String Symbol SyntaxError TypeError TypedArray URIError Uint16Array Uint32Array Uint8Array Uint8ClampedArray WeakMap WeakSet decodeURI decodeURIComponent encodeURI encodeURIComponent escape eval exports isFinite isNaN null parseFloat parseInt undefined unescape uneval'.split( ' ' );","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/disallowConflictingImports.js":"import hasOwnProp from './hasOwnProp';\n\nexport default function disallowConflictingImports ( imports ) {\n\tlet usedNames = {};\n\n\timports.forEach( x => {\n\t\tif ( x.passthrough ) return;\n\n\t\tif ( x.as ) {\n\t\t\tcheckName( x.as );\n\t\t} else {\n\t\t\tx.specifiers.forEach( checkSpecifier );\n\t\t}\n\t});\n\n\tfunction checkSpecifier ( s ) {\n\t\tcheckName( s.as );\n\t}\n\n\tfunction checkName ( name ) {\n\t\tif ( hasOwnProp.call( usedNames, name ) ) {\n\t\t\tthrow new SyntaxError( `Duplicated import ('${name}')` );\n\t\t}\n\n\t\tusedNames[ name ] = true;\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/EsperantoError.js":"var EsperantoError = function ( message, data ) {\n\tvar prop;\n\n\tthis.message = message;\n\tthis.stack = (new Error()).stack;\n\n\tfor ( prop in data ) {\n\t\tif ( data.hasOwnProperty( prop ) ) {\n\t\t\tthis[ prop ] = data[ prop ];\n\t\t}\n\t}\n};\n\nEsperantoError.prototype = new Error();\nEsperantoError.prototype.constructor = EsperantoError;\nEsperantoError.prototype.name = 'EsperantoError';\n\nexport default EsperantoError;","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/getReadOnlyIdentifiers.js":"/**\n * Scans an array of imports, and determines which identifiers\n   are readonly, and which cannot be assigned to. For example\n   you cannot `import foo from 'foo'` then do `foo = 42`, nor\n   can you `import * as foo from 'foo'` then do `foo.answer = 42`\n * @param {array} imports - the array of imports\n * @returns {array} [ importedBindings, importedNamespaces ]\n */\nexport default function getReadOnlyIdentifiers ( imports ) {\n\tvar importedBindings = {}, importedNamespaces = {};\n\n\timports.forEach( x => {\n\t\tif ( x.passthrough ) return;\n\n\t\tx.specifiers.forEach( s => {\n\t\t\tif ( s.isBatch ) {\n\t\t\t\timportedNamespaces[ s.as ] = true;\n\t\t\t} else {\n\t\t\t\timportedBindings[ s.as ] = true;\n\t\t\t}\n\t\t});\n\t});\n\n\treturn [ importedBindings, importedNamespaces ];\n}","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/hasNamedExports.js":"export default function hasNamedExports ( mod ) {\n\tvar i = mod.exports.length;\n\n\twhile ( i-- ) {\n\t\tif ( !mod.exports[i].isDefault ) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/hasNamedImports.js":"export default function hasNamedImports ( mod ) {\n\tvar i = mod.imports.length;\n\n\twhile ( i-- ) {\n\t\tif ( mod.imports[i].isNamed ) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/hasOwnProp.js":"var hasOwnProp = Object.prototype.hasOwnProperty;\nexport default hasOwnProp;","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/mappers.js":"export function getId ( m ) {\n\treturn m.id;\n}\n\nexport function getName ( m ) {\n\treturn m.name;\n}\n\nexport function quote ( str ) {\n\treturn \"'\" + JSON.stringify(str).slice(1, -1).replace(/'/g, \"\\\\'\") + \"'\";\n}\n\nexport function req ( path ) {\n\treturn `require(${quote(path)})`;\n}\n\nexport function globalify ( name ) {\n  \tif ( /^__dep\\d+__$/.test( name ) ) {\n\t\treturn 'undefined';\n\t} else {\n\t\treturn `global.${name}`;\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/packageResult.js":"import walk from './ast/walk';\nimport { splitPath } from 'utils/sanitize';\n\nconst ABSOLUTE_PATH = /^(?:[A-Z]:)?[\\/\\\\]/i;\n\nlet warned = {};\n\nexport default function packageResult ( bundleOrModule, body, options, methodName, isBundle ) {\n\t// wrap output\n\tif ( options.banner ) body.prepend( options.banner );\n\tif ( options.footer ) body.append( options.footer );\n\n\tlet code = body.toString();\n\tlet map;\n\n\tif ( !!options.sourceMap ) {\n\t\tif ( options.sourceMap !== 'inline' && !options.sourceMapFile ) {\n\t\t\tthrow new Error( 'You must provide `sourceMapFile` option' );\n\t\t}\n\n\t\tif ( !isBundle && !options.sourceMapSource ) {\n\t\t\tthrow new Error( 'You must provide `sourceMapSource` option' );\n\t\t}\n\n\t\tlet sourceMapFile;\n\t\tif ( options.sourceMap === 'inline' ) {\n\t\t\tsourceMapFile = null;\n\t\t} else {\n\t\t\tsourceMapFile = ABSOLUTE_PATH.test( options.sourceMapFile ) ? options.sourceMapFile : './' + splitPath( options.sourceMapFile ).pop();\n\t\t}\n\n\t\tif ( isBundle ) {\n\t\t\tmarkBundleSourcemapLocations( bundleOrModule );\n\t\t} else {\n\t\t\tmarkModuleSourcemapLocations( bundleOrModule );\n\t\t}\n\n\t\tmap = body.generateMap({\n\t\t\tincludeContent: true,\n\t\t\tfile: sourceMapFile,\n\t\t\tsource: ( sourceMapFile && !isBundle ) ? getRelativePath( sourceMapFile, options.sourceMapSource ) : null\n\t\t});\n\n\t\tif ( options.sourceMap === 'inline' ) {\n\t\t\tcode += '\\n//# sourceMa' + 'ppingURL=' + map.toUrl();\n\t\t\tmap = null;\n\t\t} else {\n\t\t\tcode += '\\n//# sourceMa' + 'ppingURL=' + sourceMapFile + '.map';\n\t\t}\n\t} else {\n\t\tmap = null;\n\t}\n\n\treturn {\n\t\tcode,\n\t\tmap,\n\t\ttoString () {\n\t\t\tif ( !warned[ methodName ] ) {\n\t\t\t\tconsole.log( `Warning: esperanto.${methodName}() returns an object with a 'code' property. You should use this instead of using the returned value directly` );\n\t\t\t\twarned[ methodName ] = true;\n\t\t\t}\n\n\t\t\treturn code;\n\t\t}\n\t};\n}\n\nfunction getRelativePath ( from, to ) {\n\tvar fromParts, toParts, i;\n\n\tfromParts = splitPath( from );\n\ttoParts = splitPath( to );\n\n\tfromParts.pop(); // get dirname\n\n\twhile ( fromParts[0] === '.' ) {\n\t\tfromParts.shift();\n\t}\n\n\twhile ( fromParts[0] === toParts[0] ) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif ( fromParts.length ) {\n\t\ti = fromParts.length;\n\t\twhile ( i-- ) fromParts[i] = '..';\n\n\t\treturn fromParts.concat( toParts ).join( '/' );\n\t} else {\n\t\ttoParts.unshift( '.' );\n\t\treturn toParts.join( '/' );\n\t}\n}\n\nfunction markBundleSourcemapLocations ( bundle ) {\n\tbundle.modules.forEach( mod => {\n\t\twalk( mod.ast, {\n\t\t\tenter: node => {\n\t\t\t\tmod.body.addSourcemapLocation( node.start );\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction markModuleSourcemapLocations ( mod ) {\n\twalk( mod.ast, {\n\t\tenter: node => {\n\t\t\tmod.body.addSourcemapLocation( node.start );\n\t\t}\n\t});\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/promiseSequence.js":"import { Promise } from 'sander';\n\nexport default function promiseSequence ( arr, callback ) {\n\tconst len = arr.length;\n\tlet results = new Array( len );\n\n\tlet promise = Promise.resolve();\n\n\tfunction next ( i ) {\n\t\treturn promise\n\t\t\t.then( () => callback( arr[i], i ) )\n\t\t\t.then( result => results[i] = result );\n\t}\n\n\tlet i;\n\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tpromise = next( i );\n\t}\n\n\treturn promise.then( () => results );\n}","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/resolveId.js":"import { splitPath } from 'utils/sanitize';\n\n/**\n * Resolves an importPath relative to the module that is importing it\n * @param {string} importPath - the (possibly relative) path of an imported module\n * @param {string} importerPath - the (relative to `base`) path of the importing module\n * @returns {string}\n */\nexport default function resolveId ( importPath, importerPath ) {\n\tvar resolved, importerParts, importParts;\n\n\tif ( importPath[0] !== '.' ) {\n\t\tresolved = importPath;\n\t} else {\n\t\timporterParts = splitPath( importerPath );\n\t\timportParts = splitPath( importPath );\n\n\t\tif ( importParts[0] === '.' ) {\n\t\t\timportParts.shift();\n\t\t}\n\n\t\timporterParts.pop(); // get dirname\n\t\twhile ( importParts[0] === '..' ) {\n\t\t\timportParts.shift();\n\t\t\timporterParts.pop();\n\t\t}\n\n\t\twhile ( importParts[0] === '.' ) {\n\t\t\timportParts.shift();\n\t\t}\n\n\t\tresolved = importerParts.concat( importParts ).join( '/' );\n\t}\n\n\treturn resolved;\n}\n\nexport function resolveAgainst ( importerPath ) {\n\treturn function ( importPath ) {\n\t\treturn resolveId( importPath, importerPath );\n\t};\n}\n","/home/travis/build/npmtest/node-npmtest-esperanto/node_modules/esperanto/src/utils/sanitize.js":"const RESERVED = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield'.split( ' ' );\nconst INVALID_CHAR = /[^a-zA-Z0-9_$]/g;\nconst INVALID_LEADING_CHAR = /[^a-zA-Z_$]/;\n\n/**\n * Generates a sanitized (i.e. valid identifier) name from a module ID\n * @param {string} id - a module ID, or part thereof\n * @returns {string}\n */\nexport default function sanitize ( name ) {\n\tname = name.replace( INVALID_CHAR, '_' );\n\n\tif ( INVALID_LEADING_CHAR.test( name[0] ) || ~RESERVED.indexOf( name ) ) {\n\t\tname = `_${name}`;\n\t}\n\n\treturn name;\n}\n\nvar pathSplitRE = /\\/|\\\\/;\nexport function splitPath ( path ) {\n\treturn path.split( pathSplitRE );\n}\n"}